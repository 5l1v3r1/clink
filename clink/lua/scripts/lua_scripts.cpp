#include "pch.h"
#if defined(CLINK_FINAL)
const char* lib_match_lua_script = 
"clink._modules = {}\n"
"function clink:module(priority)\n"
"    if priority == nil then priority = 999 end\n"
"    local ret = { _priority = priority }\n"
"    table.insert(self._modules, ret)\n"
"    self._modules_unsorted = true\n"
"    return ret\n"
"end\n"
"function clink:_generate_impl(line_state, match_builder)\n"
"    for _, module in ipairs(self._modules) do\n"
"        local ret = module:generate(line_state, match_builder)\n"
"        if ret == true then\n"
"            return true\n"
"        end\n"
"    end\n"
"    return false\n"
"end\n"
"function clink:_generate(line_state, match_builder)\n"
"    -- Sort modules by priority if required.\n"
"    if self._modules_unsorted then\n"
"        local lambda = function(a, b) return a._priority < b._priority end\n"
"        table.sort(self._modules, lambda)\n"
"        self._modules_unsorted = false\n"
"    end\n"
"    -- Protected call to generate matches.\n"
"    local ok, ret = pcall(self._generate_impl, self, line_state, match_builder)\n"
"    if not ok then\n"
"        print(\"\")\n"
"        print(ret)\n"
"        print(debug.traceback())\n"
"        return false\n"
"    end\n"
"    return ret\n"
"end\n"
"";const char* lib_arguments_lua_script = 
"local _arglink = {}\n"
"_arglink.__index = _arglink\n"
"setmetatable(_arglink, { __call = function (x, ...) return x._new(...) end })\n"
"function _arglink._new(key, matcher)\n"
"    return setmetatable({\n"
"        _key = key,\n"
"        _matcher = matcher,\n"
"    }, _arglink)\n"
"end\n"
"local _argreader = {}\n"
"_argreader.__index = _argreader\n"
"setmetatable(_argreader, { __call = function (x, ...) return x._new(...) end })\n"
"function _argreader._new(root)\n"
"    local reader = setmetatable({\n"
"        _matcher = root,\n"
"        _arg_index = 1,\n"
"        _stack = {},\n"
"    }, _argreader)\n"
"    return reader\n"
"end\n"
"function _argreader:update(word)\n"
"    -- Check for flags and swtich matcher if the word is a flag.\n"
"    local matcher = self._matcher\n"
"    local is_flag = matcher:_is_flag(word)\n"
"    if is_flag then\n"
"        if matcher._flags then\n"
"            self:_push(matcher._flags)\n"
"        else\n"
"            return\n"
"        end\n"
"    end\n"
"    matcher = self._matcher\n"
"    local arg_index = self._arg_index\n"
"    local arg = matcher._args[arg_index]\n"
"    arg_index = arg_index + 1\n"
"    -- If arg_index is out of bounds we should loop if set or return to the\n"
"    -- previous matcher if possible.\n"
"    if arg_index > #matcher._args then\n"
"        if matcher._loop then\n"
"            self._arg_index = math.min(math.max(matcher._loop, 1), #matcher._args)\n"
"        elseif not self:_pop() then\n"
"            self._arg_index = arg_index\n"
"        end\n"
"    else\n"
"        self._arg_index = arg_index\n"
"    end\n"
"    -- Some matchers have no args at all.\n"
"    if not arg then\n"
"        return\n"
"    end\n"
"    -- Does the word lead to another matcher?\n"
"    for key, linked in pairs(arg._links) do\n"
"        if key == word then\n"
"            self:_push(linked)\n"
"            break\n"
"        end\n"
"    end\n"
"end\n"
"function _argreader:_push(matcher)\n"
"    table.insert(self._stack, { self._matcher, self._arg_index })\n"
"    self._matcher = matcher\n"
"    self._arg_index = 1\n"
"end\n"
"function _argreader:_pop()\n"
"    if #self._stack > 0 then\n"
"        self._matcher, self._arg_index = table.unpack(table.remove(self._stack))\n"
"        return true\n"
"    end\n"
"    return false\n"
"end\n"
"local _argmatcher = {}\n"
"_argmatcher.__index = _argmatcher\n"
"setmetatable(_argmatcher, { __call = function (x, ...) return x._new(...) end })\n"
"function _argmatcher._new()\n"
"    local matcher = setmetatable({\n"
"        _args = {},\n"
"    }, _argmatcher)\n"
"    matcher:setflagprefix(\"-\")\n"
"    return matcher\n"
"end\n"
"function _argmatcher:addarg(...)\n"
"    local list = { _links = {} }\n"
"    self:_add(list, {...})\n"
"    table.insert(self._args, list)\n"
"    return self\n"
"end\n"
"function _argmatcher:addflags(...)\n"
"    local flag_matcher = self._flags or _argmatcher()\n"
"    local list = flag_matcher._args[1] or { _links = {} }\n"
"    flag_matcher:_add(list, {...})\n"
"    flag_matcher._args[1] = list\n"
"    self._flags = flag_matcher\n"
"    return self\n"
"end\n"
"function _argmatcher:loop(index)\n"
"    self._loop = index or -1\n"
"    return self\n"
"end\n"
"function _argmatcher:setflagprefix(...)\n"
"    local input = {...}\n"
"    if #input > 0 then\n"
"        for _, i in ipairs(input) do\n"
"            if type(i) ~= \"string\" or #i ~= 1 then\n"
"                error(\"Flag prefixes must be single character strings\", 2)\n"
"            end\n"
"        end\n"
"        self._flagprefix = input\n"
"    end\n"
"    return self\n"
"end\n"
"function _argmatcher:generatefiles(enabled) -- MODE4: misleading name - it's a fallback\n"
"    self._no_file_generation = not enabled\n"
"    return self\n"
"end\n"
"function _argmatcher.__concat(lhs, rhs)\n"
"    if getmetatable(rhs) ~= _argmatcher then\n"
"        error(\"Right-hand side must be an argmatcher object\", 2)\n"
"    end\n"
"    local t = type(lhs)\n"
"    if t == \"string\" then\n"
"        return _arglink(lhs, rhs)\n"
"    end\n"
"    if t == \"table\" then\n"
"        local ret = {}\n"
"        for _, i in ipairs(lhs) do\n"
"            table.insert(ret, i .. rhs)\n"
"        end\n"
"        return ret\n"
"    end\n"
"    error(\"Left-hand side must be a string or a table of strings\", 2)\n"
"end\n"
"function _argmatcher:__call(arg)\n"
"    if type(arg) ~= \"table\" then\n"
"        error(\"Shorthand matcher arguments must be tables\", 2)\n"
"    end\n"
"    local is_flag\n"
"    is_flag = function(x)\n"
"        local is_link = (getmetatable(x) == _arglink)\n"
"        if type(x) == \"table\" and not is_link then\n"
"            return is_flag(x[1])\n"
"        end\n"
"        if is_link then\n"
"            x = x._key\n"
"        end\n"
"        return self:_is_flag(tostring(x))\n"
"    end\n"
"    if is_flag(arg[1]) then\n"
"        return self:addflags(table.unpack(arg))\n"
"    end\n"
"    return self:addarg(table.unpack(arg))\n"
"end\n"
"function _argmatcher:_is_flag(word)\n"
"    local first_char = word:sub(1, 1)\n"
"    for _, i in ipairs(self._flagprefix) do\n"
"        if first_char == i then\n"
"            return true\n"
"        end\n"
"    end\n"
"    return false\n"
"end\n"
"function _argmatcher:_add(list, addee)\n"
"    -- Flatten out tables unless the table is a link\n"
"    local is_link = (getmetatable(addee) == _arglink)\n"
"    if type(addee) == \"table\" and not is_link and not addee.match then\n"
"        for _, i in ipairs(addee) do\n"
"            self:_add(list, i)\n"
"        end\n"
"        return\n"
"    end\n"
"    if is_link then\n"
"        list._links[addee._key] = addee._matcher\n"
"    else\n"
"        table.insert(list, addee)\n"
"    end\n"
"end\n"
"function _argmatcher:_generate(line_state, match_builder)\n"
"    local reader = _argreader(self)\n"
"    -- Consume words and use them to move through matchers' arguments.\n"
"    local word_count = line_state:getwordcount()\n"
"    for word_index = 2, (word_count - 1) do\n"
"        local word = line_state:getword(word_index)\n"
"        reader:update(word)\n"
"    end\n"
"    -- There should always be a matcher left on the stack, but the arg_index\n"
"    -- could be well out of range.\n"
"    local matcher = reader._matcher\n"
"    local arg_index = reader._arg_index\n"
"    -- Are we left with a valid argument that can provide matches?\n"
"    local add_matches = function(arg)\n"
"        for key, _ in pairs(arg._links) do\n"
"            match_builder:addmatch(key)\n"
"        end\n"
"        for _, i in ipairs(arg) do\n"
"            if type(i) == \"function\" then\n"
"                match_builder:addmatches(i(word_count, line_state))\n"
"            else\n"
"                match_builder:addmatch(i)\n"
"            end\n"
"        end\n"
"    end\n"
"    if matcher._flags then\n"
"        add_matches(matcher._flags._args[1])\n"
"    end\n"
"    --if not matcher._args then pause() end\n"
"    local arg = matcher._args[arg_index]\n"
"    if arg then\n"
"        add_matches(arg)\n"
"        return true\n"
"    end\n"
"    -- No valid argument. Decide if we should match files or not.\n"
"    local no_files = matcher._no_file_generation or #matcher._args == 0\n"
"    return no_files\n"
"end\n"
"clink._argmatchers = {}\n"
"function clink:argmatcher(...)\n"
"    local matcher = _argmatcher()\n"
"    -- Extract priority from the arguments.\n"
"    matcher._priority = 999\n"
"    local input = {...}\n"
"    if #input > 0 and type(input[1]) == \"number\" then\n"
"        matcher._priority = input[1]\n"
"        table.remove(input, 1)\n"
"    end\n"
"    -- Register the argmatcher\n"
"    for _, i in ipairs(input) do\n"
"        self._argmatchers[i:lower()] = matcher\n"
"    end\n"
"    return matcher\n"
"end\n"
"local argmatcher_module = clink:module(24)\n"
"function argmatcher_module:generate(line_state, match_builder)\n"
"    -- Running and argmatcher only makes sense if there's two or more words.\n"
"    if line_state:getwordcount() < 2 then\n"
"        return false\n"
"    end\n"
"    local first_word = line_state:getword(1)\n"
"    -- Search for a valid argmatcher and call it.\n"
"    local argmatcher_keys = {\n"
"        path.getname(first_word):lower(),\n"
"        path.getbasename(first_word):lower(),\n"
"    }\n"
"    for _, key in ipairs(argmatcher_keys) do\n"
"        local argmatcher = clink._argmatchers[key]\n"
"        if argmatcher then\n"
"            return argmatcher:_generate(line_state, match_builder)\n"
"        end\n"
"    end\n"
"    return false\n"
"end\n"
"clink:argmatcher('shh')\n"
"    { 'one', 'two', 'three' }\n"
"    { 'four', 'five' }\n"
"    { 'nine', 'ten', 'eleven' }\n"
"    { 'jumbbles', 'jumbles' .. clink:argmatcher() { 'red', 'green', 'blue'} }\n"
"    { { '-flag', '-hips' } .. clink:argmatcher() { 'red', 'green', 'blue'}, '-guff' }\n"
"clink:argmatcher('see')\n"
":addarg('two', 'three')\n"
":addarg('four', 'banana')\n"
":loop()\n"
"clink:argmatcher('sdd')\n"
"    :addarg(\"true\", \"sub\" .. clink:argmatcher())\n"
"    :addflags('-one', '-two', '-twenty')\n"
"    --:addflags('/one', '/two', '/twenty')\n"
"    --:setflagprefix('/')\n"
"";const char* lib_debugger_lua_script = 
"\n"
"local IsWindows = string.find(string.lower(os.getenv('OS') or ''),'^windows')\n"
"local coro_debugger\n"
"local events = { BREAK = 1, WATCH = 2, STEP = 3, SET = 4 }\n"
"local breakpoints = {}\n"
"local watches = {}\n"
"local step_into   = false\n"
"local step_over   = false\n"
"local step_lines  = 0\n"
"local step_level  = {main=0}\n"
"local stack_level = {main=0}\n"
"local trace_level = {main=0}\n"
"local trace_calls = false\n"
"local trace_returns = false\n"
"local trace_lines = false\n"
"local ret_file, ret_line, ret_name\n"
"local current_thread = 'main'\n"
"local started = false\n"
"local pause_off = false\n"
"local _g      = _G\n"
"local cocreate, cowrap = coroutine.create, coroutine.wrap\n"
"local pausemsg = 'pause'\n"
"local aliases = {\n"
"    p = \"over\",\n"
"    t = \"step\",\n"
"    q = \"exit\",\n"
"    g = \"run\",\n"
"    dv = \"dump\",\n"
"    [\"??\"] = \"dump\",\n"
"    dt = \"locs\",\n"
"    k = \"trace\",\n"
"    bp = \"setb\",\n"
"    bc = \"delb\",\n"
"    bl = \"listb\",\n"
"    pt = \"out\",\n"
"}\n"
"if not setfenv then -- Lua 5.2\n"
" --\n"
"  setfenv = setfenv or function(f, t)\n"
"    f = (type(f) == 'function' and f or debug.getinfo(f + 1, 'f').func)\n"
"    local name\n"
"    local up = 0\n"
"    repeat\n"
"      up = up + 1\n"
"      name = debug.getupvalue(f, up)\n"
"    until name == '_ENV' or name == nil\n"
"    if name then\n"
"      debug.upvaluejoin(f, up, function() return name end, 1) -- use unique upvalue\n"
"      debug.setupvalue(f, up, t)\n"
"    end\n"
"  end\n"
"  getfenv = getfenv or function(f)\n"
"    f = (type(f) == 'function' and f or debug.getinfo(f + 1, 'f').func)\n"
"    local name, val\n"
"    local up = 0\n"
"    repeat\n"
"      up = up + 1\n"
"      name, val = debug.getupvalue(f, up)\n"
"    until name == '_ENV' or name == nil\n"
"    return val\n"
"  end\n"
"  unpack = table.unpack\n"
"end\n"
"local hints = {\n"
"pause =   [[\n"
"pause(msg[,lines][,force]) -- start/resume a debugger session|\n"
"This can only be used in your code or from the console as a means to\n"
"start/resume a debug session.\n"
"If msg is given that is shown when the session starts/resumes. Useful to\n"
"give a context if you've instrumented your code with pause() statements.\n"
"If lines is given, the script pauses after that many lines, else it pauses\n"
"immediately.\n"
"If force is true, the pause function is honoured even if poff has been used.\n"
"This is useful when in an interactive console session to regain debugger\n"
"control.\n"
"]],\n"
"poff =    [[\n"
"poff                -- turn off pause() command|\n"
"This causes all pause() commands to be ignored. This is useful if you have\n"
"instrumented your code in a busy loop and want to continue normal execution\n"
"with no further interruption.\n"
"]],\n"
"pon =     [[\n"
"pon                 -- turn on pause() command|\n"
"This re-instates honouring the pause() commands you may have instrumented\n"
"your code with.\n"
"]],\n"
"setb =    [[\n"
"setb [line file]    -- set a breakpoint to line/file|, line 0 means 'any'\n"
"If file is omitted or is \"-\" the breakpoint is set at the file for the\n"
"currently set level (see \"set\"). Execution pauses when this line is about\n"
"to be executed and the debugger session is re-activated.\n"
"The file can be given as the fully qualified name, partially qualified or\n"
"just the file name. E.g. if file is set as \"myfile.lua\", then whenever\n"
"execution reaches any file that ends with \"myfile.lua\" it will pause. If\n"
"no extension is given, any extension will do.\n"
"If the line is given as 0, then reaching any line in the file will do.\n"
"]],\n"
"delb =    [[\n"
"delb [line file]    -- removes a breakpoint|\n"
"If file is omitted or is \"-\" the breakpoint is removed for the file of the\n"
"currently set level (see \"set\").\n"
"]],\n"
"delallb = [[\n"
"delallb             -- removes all breakpoints|\n"
"]],\n"
"setw =    [[\n"
"setw <exp>          -- adds a new watch expression|\n"
"The expression is evaluated before each line is executed. If the expression\n"
"yields true then execution is paused and the debugger session re-activated.\n"
"The expression is executed in the context of the line about to be executed.\n"
"]],\n"
"delw =    [[\n"
"delw <index>        -- removes the watch expression at index|\n"
"The index is that returned when the watch expression was set by setw.\n"
"]],\n"
"delallw = [[\n"
"delallw             -- removes all watch expressions|\n"
"]],\n"
"run     = [[\n"
"run                 -- run until next breakpoint or watch expression|\n"
"]],\n"
"step    = [[\n"
"step [N]            -- run next N lines, stepping into function calls|\n"
"If N is omitted, use 1.\n"
"]],\n"
"over    = [[\n"
"over [N]            -- run next N lines, stepping over function calls|\n"
"If N is omitted, use 1.\n"
"]],\n"
"out     = [[\n"
"out [N]             -- run lines until stepped out of N functions|\n"
"If N is omitted, use 1.\n"
"If you are inside a function, using \"out 1\" will run until you return\n"
"from that function to the caller.\n"
"]],\n"
"gotoo   = [[\n"
"gotoo [line file]    -- step to line in file|\n"
"This is equivalent to 'setb line file', followed by 'run', followed\n"
"by 'delb line file'.\n"
"]],\n"
"listb   = [[\n"
"listb               -- lists breakpoints|\n"
"]],\n"
"listw   = [[\n"
"listw               -- lists watch expressions|\n"
"]],\n"
"set     = [[\n"
"set [level]         -- set context to stack level, omitted=show|\n"
"If level is omitted it just prints the current level set.\n"
"This sets the current context to the level given. This affects the\n"
"context used for several other functions (e.g. vars). The possible\n"
"levels are those shown by trace.\n"
"]],\n"
"vars    = [[\n"
"vars [depth]        -- list context locals to depth, omitted=1|\n"
"If depth is omitted then uses 1.\n"
"Use a depth of 0 for the maximum.\n"
"Lists all non-nil local variables and all non-nil upvalues in the\n"
"currently set context. For variables that are tables, lists all fields\n"
"to the given depth.\n"
"]],\n"
"fenv    = [[\n"
"fenv [depth]        -- list context function env to depth, omitted=1|\n"
"If depth is omitted then uses 1.\n"
"Use a depth of 0 for the maximum.\n"
"Lists all function environment variables in the currently set context.\n"
"For variables that are tables, lists all fields to the given depth.\n"
"]],\n"
"glob    = [[\n"
"glob [depth]        -- list globals to depth, omitted=1|\n"
"If depth is omitted then uses 1.\n"
"Use a depth of 0 for the maximum.\n"
"Lists all global variables.\n"
"For variables that are tables, lists all fields to the given depth.\n"
"]],\n"
"ups     = [[\n"
"ups                 -- list all the upvalue names|\n"
"These names will also be in the \"vars\" list unless their value is nil.\n"
"This provides a means to identify which vars are upvalues and which are\n"
"locals. If a name is both an upvalue and a local, the local value takes\n"
"precedance.\n"
"]],\n"
"locs    = [[\n"
"locs                -- list all the locals names|\n"
"These names will also be in the \"vars\" list unless their value is nil.\n"
"This provides a means to identify which vars are upvalues and which are\n"
"locals. If a name is both an upvalue and a local, the local value takes\n"
"precedance.\n"
"]],\n"
"dump    = [[\n"
"dump <var> [depth]  -- dump all fields of variable to depth|\n"
"If depth is omitted then uses 1.\n"
"Use a depth of 0 for the maximum.\n"
"Prints the value of <var> in the currently set context level. If <var>\n"
"is a table, lists all fields to the given depth. <var> can be just a\n"
"name, or name.field or name.# to any depth, e.g. t.1.f accesses field\n"
"'f' in array element 1 in table 't'.\n"
"Can also be called from a script as dump(var,depth).\n"
"]],\n"
"tron    = [[\n"
"tron [crl]          -- turn trace on for (c)alls, (r)etuns, (l)lines|\n"
"If no parameter is given then tracing is turned off.\n"
"When tracing is turned on a line is printed to the console for each\n"
"debug 'event' selected. c=function calls, r=function returns, l=lines.\n"
"]],\n"
"trace   = [[\n"
"trace               -- dumps a stack trace|\n"
"Format is [level] = file,line,name\n"
"The level is a candidate for use by the 'set' command.\n"
"]],\n"
"info    = [[\n"
"info                -- dumps the complete debug info captured|\n"
"Only useful as a diagnostic aid for the debugger itself. This information\n"
"can be HUGE as it dumps all variables to the maximum depth, so be careful.\n"
"]],\n"
"show    = [[\n"
"show line file X Y  -- show X lines before and Y after line in file|\n"
"If line is omitted or is '-' then the current set context line is used.\n"
"If file is omitted or is '-' then the current set context file is used.\n"
"If file is not fully qualified and cannot be opened as specified, then\n"
"a search for the file in the package[path] is performed using the usual\n"
"\"require\" searching rules. If no file extension is given, .lua is used.\n"
"Prints the lines from the source file around the given line.\n"
"]],\n"
"exit    = [[\n"
"exit                -- exits debugger, re-start it using pause()|\n"
"]],\n"
"help    = [[\n"
"help [command]      -- show this list or help for command|\n"
"]],\n"
"[\"<statement>\"] = [[\n"
"<statement>         -- execute a statement in the current context|\n"
"The statement can be anything that is legal in the context, including\n"
"assignments. Such assignments affect the context and will be in force\n"
"immediately. Any results returned are printed. Use '=' as a short-hand\n"
"for 'return', e.g. \"=func(arg)\" will call 'func' with 'arg' and print\n"
"the results, and \"=var\" will just print the value of 'var'.\n"
"]],\n"
"what    = [[\n"
"what <func>         -- show where <func> is defined (if known)|\n"
"]],\n"
"}\n"
"local function getinfo(level,field)\n"
"  level = level + 1  --to get to the same relative level as the caller\n"
"  if not field then return debug.getinfo(level) end\n"
"  local what\n"
"  if field == 'name' or field == 'namewhat' then\n"
"    what = 'n'\n"
"  elseif field == 'what' or field == 'source' or field == 'linedefined' or field == 'lastlinedefined' or field == 'short_src' then\n"
"    what = 'S'\n"
"  elseif field == 'currentline' then\n"
"    what = 'l'\n"
"  elseif field == 'nups' then\n"
"    what = 'u'\n"
"  elseif field == 'func' then\n"
"    what = 'f'\n"
"  else\n"
"    return debug.getinfo(level,field)\n"
"  end\n"
"  local ar = debug.getinfo(level,what)\n"
"  if ar then return ar[field] else return nil end\n"
"end\n"
"local function indented( level, ... )\n"
"  io.write( string.rep('  ',level), table.concat({...}), '\\n' )\n"
"end\n"
"local dumpvisited\n"
"local function dumpval( level, name, value, limit )\n"
"  local index\n"
"  if type(name) == 'number' then\n"
"    index = string.format('[%d] = ',name)\n"
"  elseif type(name) == 'string'\n"
"     and (name == '__VARSLEVEL__' or name == '__ENVIRONMENT__' or name == '__GLOBALS__' or name == '__UPVALUES__' or name == '__LOCALS__') then\n"
"    --ignore these, they are debugger generated\n"
"    return\n"
"  elseif type(name) == 'string' and string.find(name,'^[_%a][_.%w]*$') then\n"
"    index = name ..' = '\n"
"  else\n"
"    index = string.format('[%q] = ',tostring(name))\n"
"  end\n"
"  if type(value) == 'table' then\n"
"    if dumpvisited[value] then\n"
"      indented( level, index, string.format('ref%q;',dumpvisited[value]) )\n"
"    else\n"
"      dumpvisited[value] = tostring(value)\n"
"      if (limit or 0) > 0 and level+1 >= limit then\n"
"        indented( level, index, dumpvisited[value] )\n"
"      else\n"
"        indented( level, index, '{  -- ', dumpvisited[value] )\n"
"        for n,v in pairs(value) do\n"
"          dumpval( level+1, n, v, limit )\n"
"        end\n"
"        indented( level, '};' )\n"
"      end\n"
"    end\n"
"  else\n"
"    if type(value) == 'string' then\n"
"      if string.len(value) > 40 then\n"
"        indented( level, index, '[[', value, ']];' )\n"
"      else\n"
"        indented( level, index, string.format('%q',value), ';' )\n"
"      end\n"
"    else\n"
"      indented( level, index, tostring(value), ';' )\n"
"    end\n"
"  end\n"
"end\n"
"local function dumpvar( value, limit, name )\n"
"  dumpvisited = {}\n"
"  dumpval( 0, name or tostring(value), value, limit )\n"
"end\n"
"local function show(file,line,before,after)\n"
"  line   = tonumber(line   or 1)\n"
"  before = tonumber(before or 10)\n"
"  after  = tonumber(after  or before)\n"
"  if not string.find(file,'%.') then file = file..'.lua' end\n"
"  local f = io.open(file,'r')\n"
"  if not f then\n"
"    --{{{  try to find the file in the path\n"
"    --\n"
"    -- looks for a file in the package path\n"
"    --\n"
"    local path = package.path or LUA_PATH or ''\n"
"    for c in string.gmatch (path, \"[^;]+\") do\n"
"      local c = string.gsub (c, \"%?%.lua\", file)\n"
"      f = io.open (c,'r')\n"
"      if f then\n"
"        break\n"
"      end\n"
"    end\n"
"    --}}}\n"
"    if not f then\n"
"      io.write('Cannot find '..file..'\\n')\n"
"      return\n"
"    end\n"
"  end\n"
"  local i = 0\n"
"  for l in f:lines() do\n"
"    i = i + 1\n"
"    if i >= (line-before) then\n"
"      if i > (line+after) then break end\n"
"      if i == line then\n"
"        io.write(i..'***\\t'..l..'\\n')\n"
"      else\n"
"        io.write(i..'\\t'..l..'\\n')\n"
"      end\n"
"    end\n"
"  end\n"
"  f:close()\n"
"end\n"
"local function gi( i )\n"
"  return function() i=i+1 return debug.getinfo(i),i end\n"
"end\n"
"local function gl( level, j )\n"
"  return function() j=j+1 return debug.getlocal( level, j ) end\n"
"end\n"
"local function gu( func, k )\n"
"  return function() k=k+1 return debug.getupvalue( func, k ) end\n"
"end\n"
"local  traceinfo\n"
"local function tracestack(l)\n"
"  local l = l + 1                        --NB: +1 to get level relative to caller\n"
"  traceinfo = {}\n"
"  traceinfo.pausemsg = pausemsg\n"
"  for ar,i in gi(l) do\n"
"    table.insert( traceinfo, ar )\n"
"    if ar.what ~= 'C' then\n"
"      local names  = {}\n"
"      local values = {}\n"
"      for n,v in gl(i,0) do\n"
"        if string.sub(n,1,1) ~= '(' then   --ignore internal control variables\n"
"          table.insert( names, n )\n"
"          table.insert( values, v )\n"
"        end\n"
"      end\n"
"      if #names > 0 then\n"
"        ar.lnames  = names\n"
"        ar.lvalues = values\n"
"      end\n"
"    end\n"
"    if ar.func then\n"
"      local names  = {}\n"
"      local values = {}\n"
"      for n,v in gu(ar.func,0) do\n"
"        if string.sub(n,1,1) ~= '(' then   --ignore internal control variables\n"
"          table.insert( names, n )\n"
"          table.insert( values, v )\n"
"        end\n"
"      end\n"
"      if #names > 0 then\n"
"        ar.unames  = names\n"
"        ar.uvalues = values\n"
"      end\n"
"    end\n"
"  end\n"
"end\n"
"local function trace(set)\n"
"  local mark\n"
"  for level,ar in ipairs(traceinfo) do\n"
"    if level == set then\n"
"      mark = '***'\n"
"    else\n"
"      mark = ''\n"
"    end\n"
"    io.write('['..level..']'..mark..'\\t'..(ar.name or ar.what)..' in '..ar.short_src..':'..ar.currentline..'\\n')\n"
"  end\n"
"end\n"
"local function info() dumpvar( traceinfo, 0, 'traceinfo' ) end\n"
"local function set_breakpoint(file, line, once)\n"
"  if not breakpoints[line] then\n"
"    breakpoints[line] = {}\n"
"  end\n"
"  if once then\n"
"    breakpoints[line][file] = 1\n"
"  else\n"
"    breakpoints[line][file] = true\n"
"  end\n"
"end\n"
"local function remove_breakpoint(file, line)\n"
"  if breakpoints[line] then\n"
"    breakpoints[line][file] = nil\n"
"  end\n"
"end\n"
"local function has_breakpoint(file, line)\n"
"  local isLine = breakpoints[line]\n"
"  local isZero = breakpoints[0]\n"
"  if not isLine and not isZero then return false end\n"
"  local noext = string.gsub(file,\"(%..-)$\",'',1)\n"
"  if noext == file then noext = nil end\n"
"  while file do\n"
"    if isLine and isLine[file] then\n"
"      if isLine[file] == 1 then isLine[file] = nil end\n"
"      return true\n"
"    end\n"
"    if isZero and isZero[file] then\n"
"      if isZero[file] == 1 then isZero[file] = nil end\n"
"      return true\n"
"    end\n"
"    if IsWindows then\n"
"      file = string.match(file,\"[:/\\\\](.+)$\")\n"
"    else\n"
"      file = string.match(file,\"[:/](.+)$\")\n"
"    end\n"
"  end\n"
"  while noext do\n"
"    if isLine and isLine[noext] then\n"
"      if isLine[noext] == 1 then isLine[noext] = nil end\n"
"      return true\n"
"    end\n"
"    if isZero and isZero[noext] then\n"
"      if isZero[noext] == 1 then isZero[noext] = nil end\n"
"      return true\n"
"    end\n"
"    if IsWindows then\n"
"      noext = string.match(noext,\"[:/\\\\](.+)$\")\n"
"    else\n"
"      noext = string.match(noext,\"[:/](.+)$\")\n"
"    end\n"
"  end\n"
"  return false\n"
"end\n"
"local function capture_vars(ref,level,line)\n"
"  --get vars, file and line for the given level relative to debug_hook offset by ref\n"
"  local lvl = ref + level                --NB: This includes an offset of +1 for the call to here\n"
"  --{{{  capture variables\n"
"  local ar = debug.getinfo(lvl, \"f\")\n"
"  if not ar then return {},'?',0 end\n"
"  local vars = {__UPVALUES__={}, __LOCALS__={}}\n"
"  local i\n"
"  local func = ar.func\n"
"  if func then\n"
"    i = 1\n"
"    while true do\n"
"      local name, value = debug.getupvalue(func, i)\n"
"      if not name then break end\n"
"      if string.sub(name,1,1) ~= '(' then  --NB: ignoring internal control variables\n"
"        vars[name] = value\n"
"        vars.__UPVALUES__[i] = name\n"
"      end\n"
"      i = i + 1\n"
"    end\n"
"    vars.__ENVIRONMENT__ = getfenv(func)\n"
"  end\n"
"  vars.__GLOBALS__ = getfenv(0)\n"
"  i = 1\n"
"  while true do\n"
"    local name, value = debug.getlocal(lvl, i)\n"
"    if not name then break end\n"
"    if string.sub(name,1,1) ~= '(' then    --NB: ignoring internal control variables\n"
"      vars[name] = value\n"
"      vars.__LOCALS__[i] = name\n"
"    end\n"
"    i = i + 1\n"
"  end\n"
"  vars.__VARSLEVEL__ = level\n"
"  if func then\n"
"    --NB: Do not do this until finished filling the vars table\n"
"    setmetatable(vars, { __index = getfenv(func), __newindex = getfenv(func) })\n"
"  end\n"
"  --NB: Do not read or write the vars table anymore else the metatable functions will get invoked!\n"
"  --}}}\n"
"  local file = getinfo(lvl, \"source\")\n"
"  if string.find(file, \"@\") == 1 then\n"
"    file = string.sub(file, 2)\n"
"  end\n"
"  if IsWindows then file = string.lower(file) end\n"
"  if not line then\n"
"    line = getinfo(lvl, \"currentline\")\n"
"  end\n"
"  return vars,file,line\n"
"end\n"
"local function restore_vars(ref,vars)\n"
"  if type(vars) ~= 'table' then return end\n"
"  local level = vars.__VARSLEVEL__       --NB: This level is relative to debug_hook offset by ref\n"
"  if not level then return end\n"
"  level = level + ref                    --NB: This includes an offset of +1 for the call to here\n"
"  local i\n"
"  local written_vars = {}\n"
"  i = 1\n"
"  while true do\n"
"    local name, value = debug.getlocal(level, i)\n"
"    if not name then break end\n"
"    if vars[name] and string.sub(name,1,1) ~= '(' then     --NB: ignoring internal control variables\n"
"      debug.setlocal(level, i, vars[name])\n"
"      written_vars[name] = true\n"
"    end\n"
"    i = i + 1\n"
"  end\n"
"  local ar = debug.getinfo(level, \"f\")\n"
"  if not ar then return end\n"
"  local func = ar.func\n"
"  if func then\n"
"    i = 1\n"
"    while true do\n"
"      local name, value = debug.getupvalue(func, i)\n"
"      if not name then break end\n"
"      if vars[name] and string.sub(name,1,1) ~= '(' then   --NB: ignoring internal control variables\n"
"        if not written_vars[name] then\n"
"          debug.setupvalue(func, i, vars[name])\n"
"        end\n"
"        written_vars[name] = true\n"
"      end\n"
"      i = i + 1\n"
"    end\n"
"  end\n"
"end\n"
"local function print_trace(level,depth,event,file,line,name)\n"
"  --NB: level here is relative to the caller of trace_event, so offset by 2 to get to there\n"
"  level = level + 2\n"
"  local file = file or getinfo(level,'short_src')\n"
"  local line = line or getinfo(level,'currentline')\n"
"  local name = name or getinfo(level,'name')\n"
"  local prefix = ''\n"
"  if current_thread ~= 'main' then prefix = '['..tostring(current_thread)..'] ' end\n"
"  io.write(prefix..\n"
"           string.format('%08.2f:%02i.',os.clock(),depth)..\n"
"           string.rep('.',depth%32)..\n"
"           (file or '')..' ('..(line or '')..') '..\n"
"           (name or '')..\n"
"           ' ('..event..')\\n')\n"
"end\n"
"local function trace_event(event, line, level)\n"
"  if event == 'return' and trace_returns then\n"
"    --note the line info for later\n"
"    ret_file = getinfo(level+1,'short_src')\n"
"    ret_line = getinfo(level+1,'currentline')\n"
"    ret_name = getinfo(level+1,'name')\n"
"  end\n"
"  if event ~= 'line' then return end\n"
"  local slevel = stack_level[current_thread]\n"
"  local tlevel = trace_level[current_thread]\n"
"  if trace_calls and slevel > tlevel then\n"
"    --we are now in the function called, so look back 1 level further to find the calling file and line\n"
"    print_trace(level+1,slevel-1,'c',nil,nil,getinfo(level+1,'name'))\n"
"  end\n"
"  if trace_returns and slevel < tlevel then\n"
"    print_trace(level,slevel,'r',ret_file,ret_line,ret_name)\n"
"  end\n"
"  if trace_lines then\n"
"    print_trace(level,slevel,'l')\n"
"  end\n"
"  trace_level[current_thread] = stack_level[current_thread]\n"
"end\n"
"local function report(ev, vars, file, line, idx_watch)\n"
"  function show_source()\n"
"    local src = traceinfo[1].source\n"
"    if src:sub(1, 1) == \"@\" then\n"
"      src = src:sub(2)\n"
"    end\n"
"    show(src, traceinfo[1].currentline, 2, 2)\n"
"  end\n"
"  local vars = vars or {}\n"
"  local file = file or '?'\n"
"  local line = line or 0\n"
"  local prefix = ''\n"
"  if current_thread ~= 'main' then prefix = '['..tostring(current_thread)..'] ' end\n"
"  if ev == events.STEP then\n"
"    io.write(prefix..\"Paused at file \"..file..\" line \"..line..' ('..stack_level[current_thread]..')\\n')\n"
"    show_source()\n"
"  elseif ev == events.BREAK then\n"
"    io.write(prefix..\"Paused at file \"..file..\" line \"..line..' ('..stack_level[current_thread]..') (breakpoint)\\n')\n"
"    show_source()\n"
"  elseif ev == events.WATCH then\n"
"    io.write(prefix..\"Paused at file \"..file..\" line \"..line..' ('..stack_level[current_thread]..')'..\" (watch expression \"..idx_watch.. \": [\"..watches[idx_watch].exp..\"])\\n\")\n"
"    show_source()\n"
"  elseif ev == events.SET then\n"
"    --do nothing\n"
"  else\n"
"    io.write(prefix..\"Error in application: \"..file..\" line \"..line..\"\\n\")\n"
"  end\n"
"  if ev ~= events.SET then\n"
"    if pausemsg and pausemsg ~= '' then io.write('Message: '..pausemsg..'\\n') end\n"
"    pausemsg = ''\n"
"  end\n"
"  return vars, file, line\n"
"end\n"
"local last_line = \"\"\n"
"local function debugger_loop(ev, vars, file, line, idx_watch)\n"
"  local eval_env  = vars or {}\n"
"  local breakfile = file or '?'\n"
"  local breakline = line or 0\n"
"  local command, args\n"
"  --{{{  local function getargs(spec)\n"
"  --get command arguments according to the given spec from the args string\n"
"  --the spec has a single character for each argument, arguments are separated\n"
"  --by white space, the spec characters can be one of:\n"
"  -- F for a filename    (defaults to breakfile if - given in args)\n"
"  -- L for a line number (defaults to breakline if - given in args)\n"
"  -- N for a number\n"
"  -- V for a variable name\n"
"  -- S for a string\n"
"  local function getargs(spec)\n"
"    local res={}\n"
"    local char,arg\n"
"    local ptr=1\n"
"    for i=1,string.len(spec) do\n"
"      char = string.sub(spec,i,i)\n"
"      if     char == 'F' then\n"
"        _,ptr,arg = string.find(args..' ',\"%s*([%w%p]*)%s*\",ptr)\n"
"        if not arg or arg == '' then arg = '-' end\n"
"        if arg == '-' then arg = breakfile end\n"
"      elseif char == 'L' then\n"
"        _,ptr,arg = string.find(args..' ',\"%s*([%w%p]*)%s*\",ptr)\n"
"        if not arg or arg == '' then arg = '-' end\n"
"        if arg == '-' then arg = breakline end\n"
"        arg = tonumber(arg) or 0\n"
"      elseif char == 'N' then\n"
"        _,ptr,arg = string.find(args..' ',\"%s*([%w%p]*)%s*\",ptr)\n"
"        if not arg or arg == '' then arg = '0' end\n"
"        arg = tonumber(arg) or 0\n"
"      elseif char == 'V' then\n"
"        _,ptr,arg = string.find(args..' ',\"%s*([%w%p]*)%s*\",ptr)\n"
"        if not arg or arg == '' then arg = '' end\n"
"      elseif char == 'S' then\n"
"        _,ptr,arg = string.find(args..' ',\"%s*([%w%p]*)%s*\",ptr)\n"
"        if not arg or arg == '' then arg = '' end\n"
"      else\n"
"        arg = ''\n"
"      end\n"
"      table.insert(res,arg or '')\n"
"    end\n"
"    return unpack(res)\n"
"  end\n"
"  --}}}\n"
"  while true do\n"
"    io.write(\"[DEBUG]> \")\n"
"    local line = io.read(\"*line\")\n"
"    if line == nil then io.write('\\n'); line = 'exit' end\n"
"    if line == \"\" then\n"
"        line = last_line\n"
"    else\n"
"        last_line = line\n"
"    end\n"
"    io.write(\"'\" .. last_line .. \"'\\n\")\n"
"    if string.find(line, \"^[a-z]+\") then\n"
"      command = string.sub(line, string.find(line, \"^[a-z]+\"))\n"
"      args    = string.gsub(line,\"^[a-z]+%s*\",'',1)            --strip command off line\n"
"    else\n"
"      command = ''\n"
"    end\n"
"    command = aliases[command] or command\n"
"    if command == \"setb\" then\n"
"      --{{{  set breakpoint\n"
"      local line, filename  = getargs('LF')\n"
"      if filename ~= '' and line ~= '' then\n"
"        set_breakpoint(filename,line)\n"
"        io.write(\"Breakpoint set in file \"..filename..' line '..line..'\\n')\n"
"      else\n"
"        io.write(\"Bad request\\n\")\n"
"      end\n"
"      --}}}\n"
"    elseif command == \"delb\" then\n"
"      --{{{  delete breakpoint\n"
"      local line, filename = getargs('LF')\n"
"      if filename ~= '' and line ~= '' then\n"
"        remove_breakpoint(filename, line)\n"
"        io.write(\"Breakpoint deleted from file \"..filename..' line '..line..\"\\n\")\n"
"      else\n"
"        io.write(\"Bad request\\n\")\n"
"      end\n"
"      --}}}\n"
"    elseif command == \"delallb\" then\n"
"      --{{{  delete all breakpoints\n"
"      breakpoints = {}\n"
"      io.write('All breakpoints deleted\\n')\n"
"      --}}}\n"
"    elseif command == \"listb\" then\n"
"      --{{{  list breakpoints\n"
"      for i, v in pairs(breakpoints) do\n"
"        for ii, vv in pairs(v) do\n"
"          io.write(\"Break at: \"..i..' in '..ii..'\\n')\n"
"        end\n"
"      end\n"
"      --}}}\n"
"    elseif command == \"setw\" then\n"
"      --{{{  set watch expression\n"
"      if args and args ~= '' then\n"
"        local func = loadstring(\"return(\" .. args .. \")\")\n"
"        local newidx = #watches + 1\n"
"        watches[newidx] = {func = func, exp = args}\n"
"        io.write(\"Set watch exp no. \" .. newidx..'\\n')\n"
"      else\n"
"        io.write(\"Bad request\\n\")\n"
"      end\n"
"      --}}}\n"
"    elseif command == \"delw\" then\n"
"      --{{{  delete watch expression\n"
"      local index = tonumber(args)\n"
"      if index then\n"
"        watches[index] = nil\n"
"        io.write(\"Watch expression deleted\\n\")\n"
"      else\n"
"        io.write(\"Bad request\\n\")\n"
"      end\n"
"      --}}}\n"
"    elseif command == \"delallw\" then\n"
"      --{{{  delete all watch expressions\n"
"      watches = {}\n"
"      io.write('All watch expressions deleted\\n')\n"
"      --}}}\n"
"    elseif command == \"listw\" then\n"
"      --{{{  list watch expressions\n"
"      for i, v in pairs(watches) do\n"
"        io.write(\"Watch exp. \" .. i .. \": \" .. v.exp..'\\n')\n"
"      end\n"
"      --}}}\n"
"    elseif command == \"run\" then\n"
"      --{{{  run until breakpoint\n"
"      step_into = false\n"
"      step_over = false\n"
"      return 'cont'\n"
"      --}}}\n"
"    elseif command == \"step\" then\n"
"      --{{{  step N lines (into functions)\n"
"      local N = tonumber(args) or 1\n"
"      step_over  = false\n"
"      step_into  = true\n"
"      step_lines = tonumber(N or 1)\n"
"      return 'cont'\n"
"      --}}}\n"
"    elseif command == \"over\" then\n"
"      --{{{  step N lines (over functions)\n"
"      local N = tonumber(args) or 1\n"
"      step_into  = false\n"
"      step_over  = true\n"
"      step_lines = tonumber(N or 1)\n"
"      step_level[current_thread] = stack_level[current_thread]\n"
"      return 'cont'\n"
"      --}}}\n"
"    elseif command == \"out\" then\n"
"      --{{{  step N lines (out of functions)\n"
"      local N = tonumber(args) or 1\n"
"      step_into  = false\n"
"      step_over  = true\n"
"      step_lines = 1\n"
"      step_level[current_thread] = stack_level[current_thread] - tonumber(N or 1)\n"
"      return 'cont'\n"
"      --}}}\n"
"    elseif command == \"gotoo\" then\n"
"      --{{{  step until reach line\n"
"      local line, filename = getargs('LF')\n"
"      if line ~= '' then\n"
"        step_over  = false\n"
"        step_into  = false\n"
"        if has_breakpoint(filename,line) then\n"
"          return 'cont'\n"
"        else\n"
"          set_breakpoint(filename,line,true)\n"
"          return 'cont'\n"
"        end\n"
"      else\n"
"        io.write(\"Bad request\\n\")\n"
"      end\n"
"      --}}}\n"
"    elseif command == \"set\" then\n"
"      --{{{  set/show context level\n"
"      local level = args\n"
"      if level and level == '' then level = nil end\n"
"      if level then return level end\n"
"      --}}}\n"
"    elseif command == \"vars\" then\n"
"      --{{{  list context variables\n"
"      local depth = args\n"
"      if depth and depth == '' then depth = nil end\n"
"      depth = tonumber(depth) or 1\n"
"      dumpvar(eval_env, depth+1, 'variables')\n"
"      --}}}\n"
"    elseif command == \"glob\" then\n"
"      --{{{  list global variables\n"
"      local depth = args\n"
"      if depth and depth == '' then depth = nil end\n"
"      depth = tonumber(depth) or 1\n"
"      dumpvar(eval_env.__GLOBALS__,depth+1,'globals')\n"
"      --}}}\n"
"    elseif command == \"fenv\" then\n"
"      --{{{  list function environment variables\n"
"      local depth = args\n"
"      if depth and depth == '' then depth = nil end\n"
"      depth = tonumber(depth) or 1\n"
"      dumpvar(eval_env.__ENVIRONMENT__,depth+1,'environment')\n"
"      --}}}\n"
"    elseif command == \"ups\" then\n"
"      --{{{  list upvalue names\n"
"      dumpvar(eval_env.__UPVALUES__,2,'upvalues')\n"
"      --}}}\n"
"    elseif command == \"locs\" then\n"
"      --{{{  list locals names\n"
"      dumpvar(eval_env.__LOCALS__,2,'upvalues')\n"
"      --}}}\n"
"    elseif command == \"what\" then\n"
"      --{{{  show where a function is defined\n"
"      if args and args ~= '' then\n"
"        local v = eval_env\n"
"        local n = nil\n"
"        for w in string.gmatch(args,\"[%w_]+\") do\n"
"          v = v[w]\n"
"          if n then n = n..'.'..w else n = w end\n"
"          if not v then break end\n"
"        end\n"
"        if type(v) == 'function' then\n"
"          local def = debug.getinfo(v,'S')\n"
"          if def then\n"
"            io.write(def.what..' in '..def.short_src..' '..def.linedefined..'..'..def.lastlinedefined..'\\n')\n"
"          else\n"
"            io.write('Cannot get info for '..v..'\\n')\n"
"          end\n"
"        else\n"
"          io.write(v..' is not a function\\n')\n"
"        end\n"
"      else\n"
"        io.write(\"Bad request\\n\")\n"
"      end\n"
"      --}}}\n"
"    elseif command == \"dump\" then\n"
"      --{{{  dump a variable\n"
"      local name, depth = getargs('VN')\n"
"      if name ~= '' then\n"
"        if depth == '' or depth == 0 then depth = nil end\n"
"        depth = tonumber(depth or 1)\n"
"        local v = eval_env\n"
"        local n = nil\n"
"        for w in string.gmatch(name,\"[^%.]+\") do     --get everything between dots\n"
"          if tonumber(w) then\n"
"            v = v[tonumber(w)]\n"
"          else\n"
"            v = v[w]\n"
"          end\n"
"          if n then n = n..'.'..w else n = w end\n"
"          if not v then break end\n"
"        end\n"
"        dumpvar(v,depth+1,n)\n"
"      else\n"
"        io.write(\"Bad request\\n\")\n"
"      end\n"
"      --}}}\n"
"    elseif command == \"show\" then\n"
"      --{{{  show file around a line or the current breakpoint\n"
"      local line, file, before, after = getargs('LFNN')\n"
"      if before == 0 then before = 10     end\n"
"      if after  == 0 then after  = before end\n"
"      if file ~= '' and file ~= \"=stdin\" then\n"
"        show(file,line,before,after)\n"
"      else\n"
"        io.write('Nothing to show\\n')\n"
"      end\n"
"      --}}}\n"
"    elseif command == \"poff\" then\n"
"      --{{{  turn pause command off\n"
"      pause_off = true\n"
"      --}}}\n"
"    elseif command == \"pon\" then\n"
"      --{{{  turn pause command on\n"
"      pause_off = false\n"
"      --}}}\n"
"    elseif command == \"tron\" then\n"
"      --{{{  turn tracing on/off\n"
"      local option = getargs('S')\n"
"      trace_calls   = false\n"
"      trace_returns = false\n"
"      trace_lines   = false\n"
"      if string.find(option,'c') then trace_calls   = true end\n"
"      if string.find(option,'r') then trace_returns = true end\n"
"      if string.find(option,'l') then trace_lines   = true end\n"
"      --}}}\n"
"    elseif command == \"trace\" then\n"
"      --{{{  dump a stack trace\n"
"      trace(eval_env.__VARSLEVEL__)\n"
"      --}}}\n"
"    elseif command == \"info\" then\n"
"      --{{{  dump all debug info captured\n"
"      info()\n"
"      --}}}\n"
"    elseif command == \"pause\" then\n"
"      --{{{  not allowed in here\n"
"      io.write('pause() should only be used in the script you are debugging\\n')\n"
"      --}}}\n"
"    elseif command == \"help\" then\n"
"      --{{{  help\n"
"      local command = getargs('S')\n"
"      if command ~= '' and hints[command] then\n"
"        io.write(hints[command]..'\\n')\n"
"      else\n"
"        for _,v in pairs(hints) do\n"
"          local _,_,h = string.find(v,\"(.+)|\")\n"
"          io.write(h..'\\n')\n"
"        end\n"
"      end\n"
"      --}}}\n"
"    elseif command == \"exit\" then\n"
"      --{{{  exit debugger\n"
"      return 'stop'\n"
"      --}}}\n"
"    elseif line ~= '' then\n"
"      --{{{  just execute whatever it is in the current context\n"
"      --map line starting with \"=...\" to \"return ...\"\n"
"      if string.sub(line,1,1) == '=' then line = string.gsub(line,'=','return ',1) end\n"
"      local ok, func = pcall(loadstring,line)\n"
"      if func == nil then                             --Michael.Bringmann@lsi.com\n"
"        io.write(\"Compile error: \"..line..'\\n')\n"
"      elseif not ok then\n"
"        io.write(\"Compile error: \"..func..'\\n')\n"
"      else\n"
"        setfenv(func, eval_env)\n"
"        local res = {pcall(func)}\n"
"        if res[1] then\n"
"          if res[2] then\n"
"            table.remove(res,1)\n"
"            for _,v in ipairs(res) do\n"
"              io.write(tostring(v))\n"
"              io.write('\\t')\n"
"            end\n"
"            io.write('\\n')\n"
"          end\n"
"          --update in the context\n"
"          return 0\n"
"        else\n"
"          io.write(\"Run error: \"..res[2]..'\\n')\n"
"        end\n"
"      end\n"
"      --}}}\n"
"    end\n"
"  end\n"
"end\n"
"local function debug_hook(event, line, level, thread)\n"
"  if not started then debug.sethook(); coro_debugger = nil; return end\n"
"  current_thread = thread or 'main'\n"
"  local level = level or 2\n"
"  trace_event(event,line,level)\n"
"  if event == \"call\" then\n"
"    stack_level[current_thread] = stack_level[current_thread] + 1\n"
"  elseif event == \"return\" then\n"
"    stack_level[current_thread] = stack_level[current_thread] - 1\n"
"    if stack_level[current_thread] < 0 then stack_level[current_thread] = 0 end\n"
"  else\n"
"    local vars,file,line = capture_vars(level,1,line)\n"
"    local stop, ev, idx = false, events.STEP, 0\n"
"    while true do\n"
"      for index, value in pairs(watches) do\n"
"        setfenv(value.func, vars)\n"
"        local status, res = pcall(value.func)\n"
"        if status and res then\n"
"          ev, idx = events.WATCH, index\n"
"          stop = true\n"
"          break\n"
"        end\n"
"      end\n"
"      if stop then break end\n"
"      if (step_into)\n"
"      or (step_over and (stack_level[current_thread] <= step_level[current_thread] or stack_level[current_thread] == 0)) then\n"
"        step_lines = step_lines - 1\n"
"        if step_lines < 1 then\n"
"          ev, idx = events.STEP, 0\n"
"          break\n"
"        end\n"
"      end\n"
"      if has_breakpoint(file, line) then\n"
"        ev, idx = events.BREAK, 0\n"
"        break\n"
"      end\n"
"      return\n"
"    end\n"
"    tracestack(level)\n"
"    if not coro_debugger then\n"
"      io.write(\"\\nLua Debugger\\n\")\n"
"      vars, file, line = report(ev, vars, file, line, idx)\n"
"      io.write(\"Type 'help' for commands\\n\")\n"
"      coro_debugger = true\n"
"    else\n"
"      vars, file, line = report(ev, vars, file, line, idx)\n"
"    end\n"
"    local last_next = 1\n"
"    local next = 'ask'\n"
"    local silent = false\n"
"    while true do\n"
"      if next == 'ask' then\n"
"        next = debugger_loop(ev, vars, file, line, idx)\n"
"      elseif next == 'cont' then\n"
"        return\n"
"      elseif next == 'stop' then\n"
"        started = false\n"
"        debug.sethook()\n"
"        coro_debugger = nil\n"
"        return\n"
"      elseif tonumber(next) then --get vars for given level or last level\n"
"        next = tonumber(next)\n"
"        if next == 0 then silent = true; next = last_next else silent = false end\n"
"        last_next = next\n"
"        restore_vars(level,vars)\n"
"        vars, file, line = capture_vars(level,next)\n"
"        if not silent then\n"
"          if vars and vars.__VARSLEVEL__ then\n"
"            io.write('Level: '..vars.__VARSLEVEL__..'\\n')\n"
"          else\n"
"            io.write('No level set\\n')\n"
"          end\n"
"        end\n"
"        ev = events.SET\n"
"        next = 'ask'\n"
"      else\n"
"        io.write('Unknown command from debugger_loop: '..tostring(next)..'\\n')\n"
"        io.write('Stopping debugger\\n')\n"
"        next = 'stop'\n"
"      end\n"
"    end\n"
"  end\n"
"end\n"
"_G.coroutine.create = function(f)\n"
"  local thread\n"
"  local hook, mask, count = debug.gethook()\n"
"  if hook then\n"
"    local function thread_hook(event,line)\n"
"      hook(event,line,3,thread)\n"
"    end\n"
"    thread = cocreate(function(...)\n"
"                        stack_level[thread] = 0\n"
"                        trace_level[thread] = 0\n"
"                        step_level [thread] = 0\n"
"                        debug.sethook(thread_hook,mask,count)\n"
"                        return f(...)\n"
"                      end)\n"
"    return thread\n"
"  else\n"
"    return cocreate(f)\n"
"  end\n"
"end\n"
"_G.coroutine.wrap = function(f)\n"
"  local thread\n"
"  local hook, mask, count = debug.gethook()\n"
"  if hook then\n"
"    local function thread_hook(event,line)\n"
"      hook(event,line,3,thread)\n"
"    end\n"
"    thread = cowrap(function(...)\n"
"                      stack_level[thread] = 0\n"
"                      trace_level[thread] = 0\n"
"                      step_level [thread] = 0\n"
"                      debug.sethook(thread_hook,mask,count)\n"
"                      return f(...)\n"
"                    end)\n"
"    return thread\n"
"  else\n"
"    return cowrap(f)\n"
"  end\n"
"end\n"
"function pause(x,l,f)\n"
"  if not f and pause_off then return end       --being told to ignore pauses\n"
"  pausemsg = x or 'pause'\n"
"  local lines\n"
"  local src = getinfo(2,'short_src')\n"
"  if l then\n"
"    lines = l   --being told when to stop\n"
"  elseif src == \"stdin\" then\n"
"    lines = 1   --if in a console session, stop now\n"
"  else\n"
"    lines = 2   --if in a script, stop when get out of pause()\n"
"  end\n"
"  if started then\n"
"    --we'll stop now 'cos the existing debug hook will grab us\n"
"    step_lines = lines\n"
"    step_into  = true\n"
"    debug.sethook(debug_hook, \"crl\")         --reset it in case some external agent fiddled with it\n"
"  else\n"
"    --set to stop when get out of pause()\n"
"    trace_level[current_thread] = 0\n"
"    step_level [current_thread] = 0\n"
"    stack_level[current_thread] = 1\n"
"    step_lines = lines\n"
"    step_into  = true\n"
"    started    = true\n"
"    debug.sethook(debug_hook, \"crl\")         --NB: this will cause an immediate entry to the debugger_loop\n"
"  end\n"
"end\n"
"function dump(v,depth)\n"
"  dumpvar(v,(depth or 1)+1,tostring(v))\n"
"end\n"
"local _traceback = debug.traceback       --note original function\n"
"debug.traceback = function(x)\n"
"  local assertmsg = _traceback(x)        --do original function\n"
"  pause(x)                               --let user have a look at stuff\n"
"  return assertmsg                       --carry on\n"
"end\n"
"_TRACEBACK = debug.traceback             --Lua 5.0 function\n"
"";const char* lib_lua_scripts[] = {lib_match_lua_script,lib_arguments_lua_script,lib_debugger_lua_script,nullptr,};
#else
const char* lib_match_lua_file = CLINK_BUILD_ROOT "/../../clink/lua/scripts/match.lua";
const char* lib_arguments_lua_file = CLINK_BUILD_ROOT "/../../clink/lua/scripts/arguments.lua";
const char* lib_debugger_lua_file = CLINK_BUILD_ROOT "/../../clink/lua/scripts/debugger.lua";
const char* lib_lua_files[] = {lib_match_lua_file,lib_arguments_lua_file,lib_debugger_lua_file,nullptr,};
#endif
