#include "pch.h"
#ifdef CLINK_EMBED_LUA_SCRIPTS
const char* lib_clink_lua_script = 
"function clink.split(str, sep)\n"
"    -- MODE4 : remove and add as a method to string from C++.\n"
"    local i = 1\n"
"    local ret = {}\n"
"    for _, j in function() return str:find(sep, i, true) end do\n"
"        table.insert(ret, str:sub(i, j - 1))\n"
"        i = j + 1\n"
"    end\n"
"    table.insert(ret, str:sub(i, j))\n"
"    return ret\n"
"end\n"
"";const char* lib_match_lua_script = 
"local generators = {}\n"
"local function generate_matches_impl(line_state, match_builder)\n"
"    -- clink.match_display_filter = nil MODE4\n"
"    for _, generator in ipairs(generators) do\n"
"        local ret = generator.f(line_state, match_builder)\n"
"        if ret == true then\n"
"            return true\n"
"        end\n"
"    end\n"
"    return false\n"
"end\n"
"function clink.generate_matches(line_state, match_builder)\n"
"    local ok, ret = pcall(generate_matches_impl, line_state, match_builder)\n"
"    if not ok then\n"
"        print(\"\")\n"
"        print(ret)\n"
"        print(debug.traceback())\n"
"        return false\n"
"    end\n"
"    return ret\n"
"end\n"
"function clink.register_match_generator(func, priority)\n"
"    if priority == nil then\n"
"        priority = 999\n"
"    end\n"
"    table.insert(generators, {f=func, p=priority})\n"
"    table.sort(generators, function(a, b) return a.p < b.p end)\n"
"end\n"
"";const char* lib_arguments_lua_script = 
"clink.arg = {}\n"
"local parsers               = {}\n"
"local is_parser\n"
"local is_sub_parser\n"
"local new_sub_parser\n"
"local parser_go_impl\n"
"local merge_parsers\n"
"local parser_meta_table     = {}\n"
"local sub_parser_meta_table = {}\n"
"function parser_meta_table.__concat(lhs, rhs)\n"
"    if not is_parser(rhs) then\n"
"        error(\"Right-handside must be parser.\", 2)\n"
"    end\n"
"    local t = type(lhs)\n"
"    if t == \"table\" then\n"
"        local ret = {}\n"
"        for _, i in ipairs(lhs) do\n"
"            table.insert(ret, i .. rhs)\n"
"        end\n"
"        return ret\n"
"    elseif t ~= \"string\" then\n"
"        error(\"Left-handside must be a string or a table.\", 2)\n"
"    end\n"
"    return new_sub_parser(lhs, rhs)\n"
"end\n"
"local function unfold_table(source, target)\n"
"    for _, i in ipairs(source) do\n"
"        if type(i) == \"table\" and getmetatable(i) == nil then\n"
"            unfold_table(i, target)\n"
"        else\n"
"            table.insert(target, i)\n"
"        end\n"
"    end\n"
"end\n"
"local function parser_is_flag(parser, part)\n"
"    if part == nil then\n"
"        return false\n"
"    end\n"
"    local prefix = part:sub(1, 1)\n"
"    return prefix == \"-\" or prefix == \"/\"\n"
"end\n"
"local function parser_add_arguments(parser, ...)\n"
"    for _, i in ipairs({...}) do\n"
"        -- Check all arguments are tables.\n"
"        if type(i) ~= \"table\" then\n"
"            error(\"All arguments to add_arguments() must be tables.\", 2)\n"
"        end\n"
"        -- Only parsers are allowed to be specified without being wrapped in a\n"
"        -- containing table.\n"
"        if getmetatable(i) ~= nil then\n"
"            if is_parser(i) then\n"
"                table.insert(parser.arguments, i)\n"
"            else\n"
"                error(\"Tables can't have meta-tables.\", 2)\n"
"            end\n"
"        else\n"
"            -- Expand out nested tables and insert into object's arguments table.\n"
"            local arguments = {}\n"
"            unfold_table(i, arguments)\n"
"            table.insert(parser.arguments, arguments)\n"
"        end\n"
"    end\n"
"    return parser\n"
"end\n"
"local function parser_set_arguments(parser, ...)\n"
"    parser.arguments = {}\n"
"    return parser:add_arguments(...)\n"
"end\n"
"local function parser_add_flags(parser, ...)\n"
"    local flags = {}\n"
"    unfold_table({...}, flags)\n"
"    -- Validate the specified flags.\n"
"    for _, i in ipairs(flags) do\n"
"        if is_sub_parser(i) then\n"
"            i = i.key\n"
"        end\n"
"        -- Check all flags are strings.\n"
"        if type(i) ~= \"string\" then\n"
"            error(\"All parser flags must be strings. Found \"..type(i), 2)\n"
"        end\n"
"        -- Check all flags start with a - or a /\n"
"        if not parser:is_flag(i) then\n"
"            error(\"Flags must begin with a '-' or a '/'\", 2)\n"
"        end\n"
"    end\n"
"    -- Append flags to parser's existing table of flags.\n"
"    for _, i in ipairs(flags) do\n"
"        table.insert(parser.flags, i)\n"
"    end\n"
"    return parser\n"
"end\n"
"local function parser_set_flags(parser, ...)\n"
"    parser.flags = {}\n"
"    return parser:add_flags(...)\n"
"end\n"
"local function parser_flatten_argument(parser, index, func_thunk)\n"
"    -- Sanity check the 'index' param to make sure it's valid.\n"
"    if type(index) == \"number\" then\n"
"        if index <= 0 or index > #parser.arguments then\n"
"            return parser.use_file_matching\n"
"        end\n"
"    end\n"
"    -- index == nil is a special case that returns the parser's flags\n"
"    local opts = {}\n"
"    local arg_opts\n"
"    if index == nil then\n"
"        arg_opts = parser.flags\n"
"    else\n"
"        arg_opts = parser.arguments[index]\n"
"    end\n"
"    -- Convert each argument option into a string and collect them in a table.\n"
"    for _, i in ipairs(arg_opts) do\n"
"        if is_sub_parser(i) then\n"
"            table.insert(opts, i.key)\n"
"        else\n"
"            local t = type(i)\n"
"            if t == \"function\" then\n"
"                local results = func_thunk(i)\n"
"                local t = type(results)\n"
"                if not results then\n"
"                    return parser.use_file_matching\n"
"                elseif t == \"boolean\" then\n"
"                    return (results and parser.use_file_matching)\n"
"                elseif t == \"table\" then\n"
"                    for _, j in ipairs(results) do\n"
"                        table.insert(opts, j)\n"
"                    end\n"
"                end\n"
"            elseif t == \"string\" or t == \"number\" then\n"
"                table.insert(opts, tostring(i))\n"
"            end\n"
"        end\n"
"    end\n"
"    return opts\n"
"end\n"
"local function parser_go_args(parser, state)\n"
"    local exhausted_args = false\n"
"    local exhausted_parts = false\n"
"    local part = state.parts[state.part_index]\n"
"    local arg_index = state.arg_index\n"
"    local arg_opts = parser.arguments[arg_index]\n"
"    local arg_count = #parser.arguments\n"
"    -- Is the next argument a parser? Parse control directly on to it.\n"
"    if is_parser(arg_opts) then\n"
"        state.arg_index = 1\n"
"        return parser_go_impl(arg_opts, state)\n"
"    end\n"
"    -- Advance parts state.\n"
"    state.part_index = state.part_index + 1\n"
"    if state.part_index > #state.parts then\n"
"        exhausted_parts = true\n"
"    end\n"
"    -- Advance argument state.\n"
"    state.arg_index = arg_index + 1\n"
"    if arg_index > arg_count then\n"
"        exhausted_args = true\n"
"    end\n"
"    -- We've exhausted all available arguments. We either loop or we're done.\n"
"    if parser.loop_point > 0 and state.arg_index > arg_count then\n"
"        state.arg_index = parser.loop_point\n"
"        if state.arg_index > arg_count then\n"
"            state.arg_index = arg_count\n"
"        end\n"
"    end\n"
"    -- Is there some state to process?\n"
"    if not exhausted_parts and not exhausted_args then\n"
"        local exact = false\n"
"        for _, arg_opt in ipairs(arg_opts) do\n"
"            -- Is the argument a key to a sub-parser? If so then hand control\n"
"            -- off to it.\n"
"            if is_sub_parser(arg_opt) then\n"
"                if arg_opt.key == part then\n"
"                    state.arg_index = 1\n"
"                    return parser_go_impl(arg_opt.parser, state)\n"
"                end\n"
"            end\n"
"            -- Check so see if the part has an exact match in the argument. Note\n"
"            -- that only string-type options are considered.\n"
"            if type(arg_opt) == \"string\" then\n"
"                exact = exact or arg_opt == part\n"
"            else\n"
"                exact = true\n"
"            end\n"
"        end\n"
"        -- If the parser's required to be precise then check here.\n"
"        if parser.precise and not exact then\n"
"            exhausted_args = true\n"
"        else\n"
"            return nil\n"
"        end\n"
"    end\n"
"    -- If we've no more arguments to traverse but there's still parts remaining\n"
"    -- then we start skipping arguments but keep going so that flags still get\n"
"    -- parsed (as flags have no position).\n"
"    if exhausted_args then\n"
"        state.part_index = state.part_index - 1\n"
"        if not exhausted_parts then\n"
"            if state.depth <= 1 then\n"
"                state.skip_args = true\n"
"                return\n"
"            end\n"
"            return parser.use_file_matching\n"
"        end\n"
"    end\n"
"    -- Now we've an index into the parser's arguments that matches the line\n"
"    -- state. Flatten it.\n"
"    local func_thunk = function(func)\n"
"        return func(part)\n"
"    end\n"
"    return parser:flatten_argument(arg_index, func_thunk)\n"
"end\n"
"local function parser_go_flags(parser, state)\n"
"    local part = state.parts[state.part_index]\n"
"    -- Advance parts state.\n"
"    state.part_index = state.part_index + 1\n"
"    if state.part_index > #state.parts then\n"
"        return parser:flatten_argument()\n"
"    end\n"
"    for _, arg_opt in ipairs(parser.flags) do\n"
"        if is_sub_parser(arg_opt) then\n"
"            if arg_opt.key == part then\n"
"                local arg_index_cache = state.arg_index\n"
"                local skip_args_cache = state.skip_args\n"
"                state.arg_index = 1\n"
"                state.skip_args = false\n"
"                state.depth = state.depth + 1\n"
"                local ret = parser_go_impl(arg_opt.parser, state)\n"
"                if type(ret) == \"table\" then\n"
"                    return ret\n"
"                end\n"
"                state.depth = state.depth - 1\n"
"                state.skip_args = skip_args_cache\n"
"                state.arg_index = arg_index_cache\n"
"            end\n"
"        end\n"
"    end\n"
"end\n"
"function parser_go_impl(parser, state)\n"
"    local has_flags = #parser.flags > 0\n"
"    while state.part_index <= #state.parts do\n"
"        local part = state.parts[state.part_index]\n"
"        local dispatch_func\n"
"        if has_flags and parser:is_flag(part) then\n"
"            dispatch_func = parser_go_flags\n"
"        elseif not state.skip_args then\n"
"            dispatch_func = parser_go_args\n"
"        end\n"
"        if dispatch_func ~= nil then\n"
"            local ret = dispatch_func(parser, state)\n"
"            if ret ~= nil then\n"
"                return ret\n"
"            end\n"
"        else\n"
"            state.part_index = state.part_index + 1\n"
"        end\n"
"    end\n"
"    return parser.use_file_matching\n"
"end\n"
"local function parser_go(parser, parts)\n"
"    -- Validate 'parts'.\n"
"    if type(parts) ~= \"table\" then\n"
"        error(\"'Parts' param must be a table of strings (\"..type(parts)..\").\", 2)\n"
"    else\n"
"        if #parts == 0 then\n"
"            part = { \"\" }\n"
"        end\n"
"        for i, j in ipairs(parts) do\n"
"            local t = type(parts[i])\n"
"            if t ~= \"string\" then\n"
"                error(\"'Parts' table can only contain strings; \"..j..\"=\"..t, 2)\n"
"            end\n"
"        end\n"
"    end\n"
"    local state = {\n"
"        arg_index = 1,\n"
"        part_index = 1,\n"
"        parts = parts,\n"
"        skip_args = false,\n"
"        depth = 1,\n"
"    }\n"
"    return parser_go_impl(parser, state)\n"
"end\n"
"local function parser_dump(parser, depth)\n"
"    if depth == nil then\n"
"        depth = 0\n"
"    end\n"
"    function prt(depth, index, text)\n"
"        local indent = string.sub(\"                                 \", 1, depth)\n"
"        text = tostring(text)\n"
"        print(indent..depth..\".\"..index..\" - \"..text)\n"
"    end\n"
"    -- Print arguments\n"
"    local i = 0\n"
"    for _, arg_opts in ipairs(parser.arguments) do\n"
"        for _, arg_opt in ipairs(arg_opts) do\n"
"            if is_sub_parser(arg_opt) then\n"
"                prt(depth, i, arg_opt.key)\n"
"                arg_opt.parser:dump(depth + 1)\n"
"            else\n"
"                prt(depth, i, arg_opt)\n"
"            end\n"
"        end\n"
"        i = i + 1\n"
"    end\n"
"    -- Print flags\n"
"    for _, flag in ipairs(parser.flags) do\n"
"        prt(depth, \"F\", flag)\n"
"    end\n"
"end\n"
"function parser_be_precise(parser)\n"
"    parser.precise = true\n"
"    return parser\n"
"end\n"
"function is_parser(p)\n"
"    return type(p) == \"table\" and getmetatable(p) == parser_meta_table\n"
"end\n"
"function is_sub_parser(sp)\n"
"    return type(sp) == \"table\" and getmetatable(sp) == sub_parser_meta_table\n"
"end\n"
"local function get_sub_parser(argument, str)\n"
"    for _, arg in ipairs(argument) do\n"
"        if is_sub_parser(arg) then\n"
"            if arg.key == str then\n"
"                return arg.parser\n"
"            end\n"
"        end\n"
"    end\n"
"end\n"
"function new_sub_parser(key, parser)\n"
"    local sub_parser = {}\n"
"    sub_parser.key = key\n"
"    sub_parser.parser = parser\n"
"    setmetatable(sub_parser, sub_parser_meta_table)\n"
"    return sub_parser\n"
"end\n"
"local function parser_disable_file_matching(parser)\n"
"    parser.use_file_matching = false\n"
"    return parser\n"
"end\n"
"local function parser_loop(parser, loop_point)\n"
"    if loop_point == nil or type(loop_point) ~= \"number\" or loop_point < 1 then\n"
"        loop_point = 1\n"
"    end\n"
"    parser.loop_point = loop_point\n"
"    return parser\n"
"end\n"
"local function parser_initialise(parser, ...)\n"
"    for _, word in ipairs({...}) do\n"
"        local t = type(word)\n"
"        if t == \"string\" then\n"
"            parser:add_flags(word)\n"
"        elseif t == \"table\" then\n"
"            if is_sub_parser(word) and parser_is_flag(nil, word.key) then\n"
"                parser:add_flags(word)\n"
"            else\n"
"                parser:add_arguments(word)\n"
"            end\n"
"        else\n"
"            error(\"Additional arguments to new_parser() must be tables or strings\", 2)\n"
"        end\n"
"    end\n"
"end\n"
"function clink.arg.new_parser(...)\n"
"    local parser = {}\n"
"    -- Methods\n"
"    parser.set_flags = parser_set_flags\n"
"    parser.add_flags = parser_add_flags\n"
"    parser.set_arguments = parser_set_arguments\n"
"    parser.add_arguments = parser_add_arguments\n"
"    parser.dump = parser_dump\n"
"    parser.go = parser_go\n"
"    parser.flatten_argument = parser_flatten_argument\n"
"    parser.be_precise = parser_be_precise\n"
"    parser.disable_file_matching = parser_disable_file_matching\n"
"    parser.loop = parser_loop\n"
"    parser.is_flag = parser_is_flag\n"
"    -- Members.\n"
"    parser.flags = {}\n"
"    parser.arguments = {}\n"
"    parser.precise = false\n"
"    parser.use_file_matching = true\n"
"    parser.loop_point = 0\n"
"    setmetatable(parser, parser_meta_table)\n"
"    -- If any arguments are provided treat them as parser's arguments or flags\n"
"    if ... then\n"
"        success, msg = pcall(parser_initialise, parser, ...)\n"
"        if not success then\n"
"            error(msg, 2)\n"
"        end\n"
"    end\n"
"    return parser\n"
"end\n"
"function merge_parsers(lhs, rhs)\n"
"    -- Merging parsers is not a trivial matter and this implementation is far\n"
"    -- from correct. It is however sufficient for the majority of cases.\n"
"    -- Merge flags.\n"
"    for _, rflag in ipairs(rhs.flags) do\n"
"        table.insert(lhs.flags, rflag)\n"
"    end\n"
"    -- Remove (and save value of) the first argument in RHS.\n"
"    local rhs_arg_1 = table.remove(rhs.arguments, 1)\n"
"    if rhs_arg_1 == nil then\n"
"        return\n"
"    end\n"
"    -- Get reference to the LHS's first argument table (creating it if needed).\n"
"    local lhs_arg_1 = lhs.arguments[1]\n"
"    if lhs_arg_1 == nil then\n"
"        lhs_arg_1 = {}\n"
"        table.insert(lhs.arguments, lhs_arg_1)\n"
"    end\n"
"    -- Link RHS to LHS through sub-parsers.\n"
"    for _, rarg in ipairs(rhs_arg_1) do\n"
"        local child\n"
"        -- Split sub parser\n"
"        if is_sub_parser(rarg) then\n"
"            child = rarg.parser\n"
"            rarg = rarg.key\n"
"        else\n"
"            child = rhs\n"
"        end\n"
"        -- If LHS's first argument has rarg in it which links to a sub-parser\n"
"        -- then we need to recursively merge them.\n"
"        local lhs_sub_parser = get_sub_parser(lhs_arg_1, rarg)\n"
"        if lhs_sub_parser then\n"
"            merge_parsers(lhs_sub_parser, child)\n"
"        else\n"
"            local to_add = rarg\n"
"            if type(rarg) ~= \"function\" then\n"
"                to_add = rarg .. child\n"
"            end\n"
"            table.insert(lhs_arg_1, to_add)\n"
"        end\n"
"    end\n"
"end\n"
"function clink.arg.register_parser(cmd, parser)\n"
"    if not is_parser(parser) then\n"
"        local p = clink.arg.new_parser()\n"
"        p:set_arguments({ parser })\n"
"        parser = p\n"
"    end\n"
"    cmd = cmd:lower()\n"
"    local prev = parsers[cmd]\n"
"    if prev ~= nil then\n"
"        merge_parsers(prev, parser)\n"
"    else\n"
"        parsers[cmd] = parser\n"
"    end\n"
"end\n"
"local function argument_match_generator(line_state, match_builder)\n"
"    -- Split the first word into name and extension.\n"
"    local first_word = line_state:getword(1)\n"
"    local cmd = path.getbasename(first_word):lower()\n"
"    local ext = path.getextension(first_word):lower()\n"
"    -- Check to make sure the extension extracted is in pathext.\n"
"    if ext and ext ~= \"\" then\n"
"        if not os.getenv(\"pathext\"):lower():match(ext..\"[;$]\", 1, true) then\n"
"            return false\n"
"        end\n"
"    end\n"
"    -- Find a registered parser.\n"
"    local parser = parsers[cmd]\n"
"    if parser == nil then\n"
"        return false\n"
"    end\n"
"    -- Turn the line state into parts (MODE4: use line_state directly!)\n"
"    local parts = {}\n"
"    for i = 2, line_state:getwordcount() do\n"
"        table.insert(parts, line_state:getword(i))\n"
"    end\n"
"    -- Call the parser.\n"
"    local ret = parser:go(parts)\n"
"    if type(ret) ~= \"table\" then\n"
"        return not ret\n"
"    end\n"
"    match_builder:add(ret)\n"
"    return true\n"
"end\n"
"clink.register_match_generator(argument_match_generator, 25)\n"
"";const char* lib_debugger_lua_script = 
"\n"
"local IsWindows = string.find(string.lower(os.getenv('OS') or ''),'^windows')\n"
"local coro_debugger\n"
"local events = { BREAK = 1, WATCH = 2, STEP = 3, SET = 4 }\n"
"local breakpoints = {}\n"
"local watches = {}\n"
"local step_into   = false\n"
"local step_over   = false\n"
"local step_lines  = 0\n"
"local step_level  = {main=0}\n"
"local stack_level = {main=0}\n"
"local trace_level = {main=0}\n"
"local trace_calls = false\n"
"local trace_returns = false\n"
"local trace_lines = false\n"
"local ret_file, ret_line, ret_name\n"
"local current_thread = 'main'\n"
"local started = false\n"
"local pause_off = false\n"
"local _g      = _G\n"
"local cocreate, cowrap = coroutine.create, coroutine.wrap\n"
"local pausemsg = 'pause'\n"
"local aliases = {\n"
"    p = \"over\",\n"
"    t = \"step\",\n"
"    q = \"exit\",\n"
"    g = \"run\",\n"
"    dv = \"dump\",\n"
"    [\"??\"] = \"dump\",\n"
"    dt = \"locs\",\n"
"    k = \"trace\",\n"
"    bp = \"setb\",\n"
"    bc = \"delb\",\n"
"    bl = \"listb\",\n"
"    pt = \"out\",\n"
"}\n"
"if not setfenv then -- Lua 5.2\n"
" --\n"
"  setfenv = setfenv or function(f, t)\n"
"    f = (type(f) == 'function' and f or debug.getinfo(f + 1, 'f').func)\n"
"    local name\n"
"    local up = 0\n"
"    repeat\n"
"      up = up + 1\n"
"      name = debug.getupvalue(f, up)\n"
"    until name == '_ENV' or name == nil\n"
"    if name then\n"
"      debug.upvaluejoin(f, up, function() return name end, 1) -- use unique upvalue\n"
"      debug.setupvalue(f, up, t)\n"
"    end\n"
"  end\n"
"  getfenv = getfenv or function(f)\n"
"    f = (type(f) == 'function' and f or debug.getinfo(f + 1, 'f').func)\n"
"    local name, val\n"
"    local up = 0\n"
"    repeat\n"
"      up = up + 1\n"
"      name, val = debug.getupvalue(f, up)\n"
"    until name == '_ENV' or name == nil\n"
"    return val\n"
"  end\n"
"  unpack = table.unpack\n"
"end\n"
"local hints = {\n"
"pause =   [[\n"
"pause(msg[,lines][,force]) -- start/resume a debugger session|\n"
"This can only be used in your code or from the console as a means to\n"
"start/resume a debug session.\n"
"If msg is given that is shown when the session starts/resumes. Useful to\n"
"give a context if you've instrumented your code with pause() statements.\n"
"If lines is given, the script pauses after that many lines, else it pauses\n"
"immediately.\n"
"If force is true, the pause function is honoured even if poff has been used.\n"
"This is useful when in an interactive console session to regain debugger\n"
"control.\n"
"]],\n"
"poff =    [[\n"
"poff                -- turn off pause() command|\n"
"This causes all pause() commands to be ignored. This is useful if you have\n"
"instrumented your code in a busy loop and want to continue normal execution\n"
"with no further interruption.\n"
"]],\n"
"pon =     [[\n"
"pon                 -- turn on pause() command|\n"
"This re-instates honouring the pause() commands you may have instrumented\n"
"your code with.\n"
"]],\n"
"setb =    [[\n"
"setb [line file]    -- set a breakpoint to line/file|, line 0 means 'any'\n"
"If file is omitted or is \"-\" the breakpoint is set at the file for the\n"
"currently set level (see \"set\"). Execution pauses when this line is about\n"
"to be executed and the debugger session is re-activated.\n"
"The file can be given as the fully qualified name, partially qualified or\n"
"just the file name. E.g. if file is set as \"myfile.lua\", then whenever\n"
"execution reaches any file that ends with \"myfile.lua\" it will pause. If\n"
"no extension is given, any extension will do.\n"
"If the line is given as 0, then reaching any line in the file will do.\n"
"]],\n"
"delb =    [[\n"
"delb [line file]    -- removes a breakpoint|\n"
"If file is omitted or is \"-\" the breakpoint is removed for the file of the\n"
"currently set level (see \"set\").\n"
"]],\n"
"delallb = [[\n"
"delallb             -- removes all breakpoints|\n"
"]],\n"
"setw =    [[\n"
"setw <exp>          -- adds a new watch expression|\n"
"The expression is evaluated before each line is executed. If the expression\n"
"yields true then execution is paused and the debugger session re-activated.\n"
"The expression is executed in the context of the line about to be executed.\n"
"]],\n"
"delw =    [[\n"
"delw <index>        -- removes the watch expression at index|\n"
"The index is that returned when the watch expression was set by setw.\n"
"]],\n"
"delallw = [[\n"
"delallw             -- removes all watch expressions|\n"
"]],\n"
"run     = [[\n"
"run                 -- run until next breakpoint or watch expression|\n"
"]],\n"
"step    = [[\n"
"step [N]            -- run next N lines, stepping into function calls|\n"
"If N is omitted, use 1.\n"
"]],\n"
"over    = [[\n"
"over [N]            -- run next N lines, stepping over function calls|\n"
"If N is omitted, use 1.\n"
"]],\n"
"out     = [[\n"
"out [N]             -- run lines until stepped out of N functions|\n"
"If N is omitted, use 1.\n"
"If you are inside a function, using \"out 1\" will run until you return\n"
"from that function to the caller.\n"
"]],\n"
"gotoo   = [[\n"
"gotoo [line file]    -- step to line in file|\n"
"This is equivalent to 'setb line file', followed by 'run', followed\n"
"by 'delb line file'.\n"
"]],\n"
"listb   = [[\n"
"listb               -- lists breakpoints|\n"
"]],\n"
"listw   = [[\n"
"listw               -- lists watch expressions|\n"
"]],\n"
"set     = [[\n"
"set [level]         -- set context to stack level, omitted=show|\n"
"If level is omitted it just prints the current level set.\n"
"This sets the current context to the level given. This affects the\n"
"context used for several other functions (e.g. vars). The possible\n"
"levels are those shown by trace.\n"
"]],\n"
"vars    = [[\n"
"vars [depth]        -- list context locals to depth, omitted=1|\n"
"If depth is omitted then uses 1.\n"
"Use a depth of 0 for the maximum.\n"
"Lists all non-nil local variables and all non-nil upvalues in the\n"
"currently set context. For variables that are tables, lists all fields\n"
"to the given depth.\n"
"]],\n"
"fenv    = [[\n"
"fenv [depth]        -- list context function env to depth, omitted=1|\n"
"If depth is omitted then uses 1.\n"
"Use a depth of 0 for the maximum.\n"
"Lists all function environment variables in the currently set context.\n"
"For variables that are tables, lists all fields to the given depth.\n"
"]],\n"
"glob    = [[\n"
"glob [depth]        -- list globals to depth, omitted=1|\n"
"If depth is omitted then uses 1.\n"
"Use a depth of 0 for the maximum.\n"
"Lists all global variables.\n"
"For variables that are tables, lists all fields to the given depth.\n"
"]],\n"
"ups     = [[\n"
"ups                 -- list all the upvalue names|\n"
"These names will also be in the \"vars\" list unless their value is nil.\n"
"This provides a means to identify which vars are upvalues and which are\n"
"locals. If a name is both an upvalue and a local, the local value takes\n"
"precedance.\n"
"]],\n"
"locs    = [[\n"
"locs                -- list all the locals names|\n"
"These names will also be in the \"vars\" list unless their value is nil.\n"
"This provides a means to identify which vars are upvalues and which are\n"
"locals. If a name is both an upvalue and a local, the local value takes\n"
"precedance.\n"
"]],\n"
"dump    = [[\n"
"dump <var> [depth]  -- dump all fields of variable to depth|\n"
"If depth is omitted then uses 1.\n"
"Use a depth of 0 for the maximum.\n"
"Prints the value of <var> in the currently set context level. If <var>\n"
"is a table, lists all fields to the given depth. <var> can be just a\n"
"name, or name.field or name.# to any depth, e.g. t.1.f accesses field\n"
"'f' in array element 1 in table 't'.\n"
"Can also be called from a script as dump(var,depth).\n"
"]],\n"
"tron    = [[\n"
"tron [crl]          -- turn trace on for (c)alls, (r)etuns, (l)lines|\n"
"If no parameter is given then tracing is turned off.\n"
"When tracing is turned on a line is printed to the console for each\n"
"debug 'event' selected. c=function calls, r=function returns, l=lines.\n"
"]],\n"
"trace   = [[\n"
"trace               -- dumps a stack trace|\n"
"Format is [level] = file,line,name\n"
"The level is a candidate for use by the 'set' command.\n"
"]],\n"
"info    = [[\n"
"info                -- dumps the complete debug info captured|\n"
"Only useful as a diagnostic aid for the debugger itself. This information\n"
"can be HUGE as it dumps all variables to the maximum depth, so be careful.\n"
"]],\n"
"show    = [[\n"
"show line file X Y  -- show X lines before and Y after line in file|\n"
"If line is omitted or is '-' then the current set context line is used.\n"
"If file is omitted or is '-' then the current set context file is used.\n"
"If file is not fully qualified and cannot be opened as specified, then\n"
"a search for the file in the package[path] is performed using the usual\n"
"\"require\" searching rules. If no file extension is given, .lua is used.\n"
"Prints the lines from the source file around the given line.\n"
"]],\n"
"exit    = [[\n"
"exit                -- exits debugger, re-start it using pause()|\n"
"]],\n"
"help    = [[\n"
"help [command]      -- show this list or help for command|\n"
"]],\n"
"[\"<statement>\"] = [[\n"
"<statement>         -- execute a statement in the current context|\n"
"The statement can be anything that is legal in the context, including\n"
"assignments. Such assignments affect the context and will be in force\n"
"immediately. Any results returned are printed. Use '=' as a short-hand\n"
"for 'return', e.g. \"=func(arg)\" will call 'func' with 'arg' and print\n"
"the results, and \"=var\" will just print the value of 'var'.\n"
"]],\n"
"what    = [[\n"
"what <func>         -- show where <func> is defined (if known)|\n"
"]],\n"
"}\n"
"local function getinfo(level,field)\n"
"  level = level + 1  --to get to the same relative level as the caller\n"
"  if not field then return debug.getinfo(level) end\n"
"  local what\n"
"  if field == 'name' or field == 'namewhat' then\n"
"    what = 'n'\n"
"  elseif field == 'what' or field == 'source' or field == 'linedefined' or field == 'lastlinedefined' or field == 'short_src' then\n"
"    what = 'S'\n"
"  elseif field == 'currentline' then\n"
"    what = 'l'\n"
"  elseif field == 'nups' then\n"
"    what = 'u'\n"
"  elseif field == 'func' then\n"
"    what = 'f'\n"
"  else\n"
"    return debug.getinfo(level,field)\n"
"  end\n"
"  local ar = debug.getinfo(level,what)\n"
"  if ar then return ar[field] else return nil end\n"
"end\n"
"local function indented( level, ... )\n"
"  io.write( string.rep('  ',level), table.concat({...}), '\\n' )\n"
"end\n"
"local dumpvisited\n"
"local function dumpval( level, name, value, limit )\n"
"  local index\n"
"  if type(name) == 'number' then\n"
"    index = string.format('[%d] = ',name)\n"
"  elseif type(name) == 'string'\n"
"     and (name == '__VARSLEVEL__' or name == '__ENVIRONMENT__' or name == '__GLOBALS__' or name == '__UPVALUES__' or name == '__LOCALS__') then\n"
"    --ignore these, they are debugger generated\n"
"    return\n"
"  elseif type(name) == 'string' and string.find(name,'^[_%a][_.%w]*$') then\n"
"    index = name ..' = '\n"
"  else\n"
"    index = string.format('[%q] = ',tostring(name))\n"
"  end\n"
"  if type(value) == 'table' then\n"
"    if dumpvisited[value] then\n"
"      indented( level, index, string.format('ref%q;',dumpvisited[value]) )\n"
"    else\n"
"      dumpvisited[value] = tostring(value)\n"
"      if (limit or 0) > 0 and level+1 >= limit then\n"
"        indented( level, index, dumpvisited[value] )\n"
"      else\n"
"        indented( level, index, '{  -- ', dumpvisited[value] )\n"
"        for n,v in pairs(value) do\n"
"          dumpval( level+1, n, v, limit )\n"
"        end\n"
"        indented( level, '};' )\n"
"      end\n"
"    end\n"
"  else\n"
"    if type(value) == 'string' then\n"
"      if string.len(value) > 40 then\n"
"        indented( level, index, '[[', value, ']];' )\n"
"      else\n"
"        indented( level, index, string.format('%q',value), ';' )\n"
"      end\n"
"    else\n"
"      indented( level, index, tostring(value), ';' )\n"
"    end\n"
"  end\n"
"end\n"
"local function dumpvar( value, limit, name )\n"
"  dumpvisited = {}\n"
"  dumpval( 0, name or tostring(value), value, limit )\n"
"end\n"
"local function show(file,line,before,after)\n"
"  line   = tonumber(line   or 1)\n"
"  before = tonumber(before or 10)\n"
"  after  = tonumber(after  or before)\n"
"  if not string.find(file,'%.') then file = file..'.lua' end\n"
"  local f = io.open(file,'r')\n"
"  if not f then\n"
"    --{{{  try to find the file in the path\n"
"    --\n"
"    -- looks for a file in the package path\n"
"    --\n"
"    local path = package.path or LUA_PATH or ''\n"
"    for c in string.gmatch (path, \"[^;]+\") do\n"
"      local c = string.gsub (c, \"%?%.lua\", file)\n"
"      f = io.open (c,'r')\n"
"      if f then\n"
"        break\n"
"      end\n"
"    end\n"
"    --}}}\n"
"    if not f then\n"
"      io.write('Cannot find '..file..'\\n')\n"
"      return\n"
"    end\n"
"  end\n"
"  local i = 0\n"
"  for l in f:lines() do\n"
"    i = i + 1\n"
"    if i >= (line-before) then\n"
"      if i > (line+after) then break end\n"
"      if i == line then\n"
"        io.write(i..'***\\t'..l..'\\n')\n"
"      else\n"
"        io.write(i..'\\t'..l..'\\n')\n"
"      end\n"
"    end\n"
"  end\n"
"  f:close()\n"
"end\n"
"local function gi( i )\n"
"  return function() i=i+1 return debug.getinfo(i),i end\n"
"end\n"
"local function gl( level, j )\n"
"  return function() j=j+1 return debug.getlocal( level, j ) end\n"
"end\n"
"local function gu( func, k )\n"
"  return function() k=k+1 return debug.getupvalue( func, k ) end\n"
"end\n"
"local  traceinfo\n"
"local function tracestack(l)\n"
"  local l = l + 1                        --NB: +1 to get level relative to caller\n"
"  traceinfo = {}\n"
"  traceinfo.pausemsg = pausemsg\n"
"  for ar,i in gi(l) do\n"
"    table.insert( traceinfo, ar )\n"
"    if ar.what ~= 'C' then\n"
"      local names  = {}\n"
"      local values = {}\n"
"      for n,v in gl(i,0) do\n"
"        if string.sub(n,1,1) ~= '(' then   --ignore internal control variables\n"
"          table.insert( names, n )\n"
"          table.insert( values, v )\n"
"        end\n"
"      end\n"
"      if #names > 0 then\n"
"        ar.lnames  = names\n"
"        ar.lvalues = values\n"
"      end\n"
"    end\n"
"    if ar.func then\n"
"      local names  = {}\n"
"      local values = {}\n"
"      for n,v in gu(ar.func,0) do\n"
"        if string.sub(n,1,1) ~= '(' then   --ignore internal control variables\n"
"          table.insert( names, n )\n"
"          table.insert( values, v )\n"
"        end\n"
"      end\n"
"      if #names > 0 then\n"
"        ar.unames  = names\n"
"        ar.uvalues = values\n"
"      end\n"
"    end\n"
"  end\n"
"end\n"
"local function trace(set)\n"
"  local mark\n"
"  for level,ar in ipairs(traceinfo) do\n"
"    if level == set then\n"
"      mark = '***'\n"
"    else\n"
"      mark = ''\n"
"    end\n"
"    io.write('['..level..']'..mark..'\\t'..(ar.name or ar.what)..' in '..ar.short_src..':'..ar.currentline..'\\n')\n"
"  end\n"
"end\n"
"local function info() dumpvar( traceinfo, 0, 'traceinfo' ) end\n"
"local function set_breakpoint(file, line, once)\n"
"  if not breakpoints[line] then\n"
"    breakpoints[line] = {}\n"
"  end\n"
"  if once then\n"
"    breakpoints[line][file] = 1\n"
"  else\n"
"    breakpoints[line][file] = true\n"
"  end\n"
"end\n"
"local function remove_breakpoint(file, line)\n"
"  if breakpoints[line] then\n"
"    breakpoints[line][file] = nil\n"
"  end\n"
"end\n"
"local function has_breakpoint(file, line)\n"
"  local isLine = breakpoints[line]\n"
"  local isZero = breakpoints[0]\n"
"  if not isLine and not isZero then return false end\n"
"  local noext = string.gsub(file,\"(%..-)$\",'',1)\n"
"  if noext == file then noext = nil end\n"
"  while file do\n"
"    if isLine and isLine[file] then\n"
"      if isLine[file] == 1 then isLine[file] = nil end\n"
"      return true\n"
"    end\n"
"    if isZero and isZero[file] then\n"
"      if isZero[file] == 1 then isZero[file] = nil end\n"
"      return true\n"
"    end\n"
"    if IsWindows then\n"
"      file = string.match(file,\"[:/\\\\](.+)$\")\n"
"    else\n"
"      file = string.match(file,\"[:/](.+)$\")\n"
"    end\n"
"  end\n"
"  while noext do\n"
"    if isLine and isLine[noext] then\n"
"      if isLine[noext] == 1 then isLine[noext] = nil end\n"
"      return true\n"
"    end\n"
"    if isZero and isZero[noext] then\n"
"      if isZero[noext] == 1 then isZero[noext] = nil end\n"
"      return true\n"
"    end\n"
"    if IsWindows then\n"
"      noext = string.match(noext,\"[:/\\\\](.+)$\")\n"
"    else\n"
"      noext = string.match(noext,\"[:/](.+)$\")\n"
"    end\n"
"  end\n"
"  return false\n"
"end\n"
"local function capture_vars(ref,level,line)\n"
"  --get vars, file and line for the given level relative to debug_hook offset by ref\n"
"  local lvl = ref + level                --NB: This includes an offset of +1 for the call to here\n"
"  --{{{  capture variables\n"
"  local ar = debug.getinfo(lvl, \"f\")\n"
"  if not ar then return {},'?',0 end\n"
"  local vars = {__UPVALUES__={}, __LOCALS__={}}\n"
"  local i\n"
"  local func = ar.func\n"
"  if func then\n"
"    i = 1\n"
"    while true do\n"
"      local name, value = debug.getupvalue(func, i)\n"
"      if not name then break end\n"
"      if string.sub(name,1,1) ~= '(' then  --NB: ignoring internal control variables\n"
"        vars[name] = value\n"
"        vars.__UPVALUES__[i] = name\n"
"      end\n"
"      i = i + 1\n"
"    end\n"
"    vars.__ENVIRONMENT__ = getfenv(func)\n"
"  end\n"
"  vars.__GLOBALS__ = getfenv(0)\n"
"  i = 1\n"
"  while true do\n"
"    local name, value = debug.getlocal(lvl, i)\n"
"    if not name then break end\n"
"    if string.sub(name,1,1) ~= '(' then    --NB: ignoring internal control variables\n"
"      vars[name] = value\n"
"      vars.__LOCALS__[i] = name\n"
"    end\n"
"    i = i + 1\n"
"  end\n"
"  vars.__VARSLEVEL__ = level\n"
"  if func then\n"
"    --NB: Do not do this until finished filling the vars table\n"
"    setmetatable(vars, { __index = getfenv(func), __newindex = getfenv(func) })\n"
"  end\n"
"  --NB: Do not read or write the vars table anymore else the metatable functions will get invoked!\n"
"  --}}}\n"
"  local file = getinfo(lvl, \"source\")\n"
"  if string.find(file, \"@\") == 1 then\n"
"    file = string.sub(file, 2)\n"
"  end\n"
"  if IsWindows then file = string.lower(file) end\n"
"  if not line then\n"
"    line = getinfo(lvl, \"currentline\")\n"
"  end\n"
"  return vars,file,line\n"
"end\n"
"local function restore_vars(ref,vars)\n"
"  if type(vars) ~= 'table' then return end\n"
"  local level = vars.__VARSLEVEL__       --NB: This level is relative to debug_hook offset by ref\n"
"  if not level then return end\n"
"  level = level + ref                    --NB: This includes an offset of +1 for the call to here\n"
"  local i\n"
"  local written_vars = {}\n"
"  i = 1\n"
"  while true do\n"
"    local name, value = debug.getlocal(level, i)\n"
"    if not name then break end\n"
"    if vars[name] and string.sub(name,1,1) ~= '(' then     --NB: ignoring internal control variables\n"
"      debug.setlocal(level, i, vars[name])\n"
"      written_vars[name] = true\n"
"    end\n"
"    i = i + 1\n"
"  end\n"
"  local ar = debug.getinfo(level, \"f\")\n"
"  if not ar then return end\n"
"  local func = ar.func\n"
"  if func then\n"
"    i = 1\n"
"    while true do\n"
"      local name, value = debug.getupvalue(func, i)\n"
"      if not name then break end\n"
"      if vars[name] and string.sub(name,1,1) ~= '(' then   --NB: ignoring internal control variables\n"
"        if not written_vars[name] then\n"
"          debug.setupvalue(func, i, vars[name])\n"
"        end\n"
"        written_vars[name] = true\n"
"      end\n"
"      i = i + 1\n"
"    end\n"
"  end\n"
"end\n"
"local function print_trace(level,depth,event,file,line,name)\n"
"  --NB: level here is relative to the caller of trace_event, so offset by 2 to get to there\n"
"  level = level + 2\n"
"  local file = file or getinfo(level,'short_src')\n"
"  local line = line or getinfo(level,'currentline')\n"
"  local name = name or getinfo(level,'name')\n"
"  local prefix = ''\n"
"  if current_thread ~= 'main' then prefix = '['..tostring(current_thread)..'] ' end\n"
"  io.write(prefix..\n"
"           string.format('%08.2f:%02i.',os.clock(),depth)..\n"
"           string.rep('.',depth%32)..\n"
"           (file or '')..' ('..(line or '')..') '..\n"
"           (name or '')..\n"
"           ' ('..event..')\\n')\n"
"end\n"
"local function trace_event(event, line, level)\n"
"  if event == 'return' and trace_returns then\n"
"    --note the line info for later\n"
"    ret_file = getinfo(level+1,'short_src')\n"
"    ret_line = getinfo(level+1,'currentline')\n"
"    ret_name = getinfo(level+1,'name')\n"
"  end\n"
"  if event ~= 'line' then return end\n"
"  local slevel = stack_level[current_thread]\n"
"  local tlevel = trace_level[current_thread]\n"
"  if trace_calls and slevel > tlevel then\n"
"    --we are now in the function called, so look back 1 level further to find the calling file and line\n"
"    print_trace(level+1,slevel-1,'c',nil,nil,getinfo(level+1,'name'))\n"
"  end\n"
"  if trace_returns and slevel < tlevel then\n"
"    print_trace(level,slevel,'r',ret_file,ret_line,ret_name)\n"
"  end\n"
"  if trace_lines then\n"
"    print_trace(level,slevel,'l')\n"
"  end\n"
"  trace_level[current_thread] = stack_level[current_thread]\n"
"end\n"
"local function report(ev, vars, file, line, idx_watch)\n"
"  function show_source()\n"
"    show(traceinfo[1].short_src, traceinfo[1].currentline, 2, 2)\n"
"  end\n"
"  local vars = vars or {}\n"
"  local file = file or '?'\n"
"  local line = line or 0\n"
"  local prefix = ''\n"
"  if current_thread ~= 'main' then prefix = '['..tostring(current_thread)..'] ' end\n"
"  if ev == events.STEP then\n"
"    io.write(prefix..\"Paused at file \"..file..\" line \"..line..' ('..stack_level[current_thread]..')\\n')\n"
"    show_source()\n"
"  elseif ev == events.BREAK then\n"
"    io.write(prefix..\"Paused at file \"..file..\" line \"..line..' ('..stack_level[current_thread]..') (breakpoint)\\n')\n"
"    show_source()\n"
"  elseif ev == events.WATCH then\n"
"    io.write(prefix..\"Paused at file \"..file..\" line \"..line..' ('..stack_level[current_thread]..')'..\" (watch expression \"..idx_watch.. \": [\"..watches[idx_watch].exp..\"])\\n\")\n"
"    show_source()\n"
"  elseif ev == events.SET then\n"
"    --do nothing\n"
"  else\n"
"    io.write(prefix..\"Error in application: \"..file..\" line \"..line..\"\\n\")\n"
"  end\n"
"  if ev ~= events.SET then\n"
"    if pausemsg and pausemsg ~= '' then io.write('Message: '..pausemsg..'\\n') end\n"
"    pausemsg = ''\n"
"  end\n"
"  return vars, file, line\n"
"end\n"
"local last_line = \"\"\n"
"local function debugger_loop(ev, vars, file, line, idx_watch)\n"
"  local eval_env  = vars or {}\n"
"  local breakfile = file or '?'\n"
"  local breakline = line or 0\n"
"  local command, args\n"
"  --{{{  local function getargs(spec)\n"
"  --get command arguments according to the given spec from the args string\n"
"  --the spec has a single character for each argument, arguments are separated\n"
"  --by white space, the spec characters can be one of:\n"
"  -- F for a filename    (defaults to breakfile if - given in args)\n"
"  -- L for a line number (defaults to breakline if - given in args)\n"
"  -- N for a number\n"
"  -- V for a variable name\n"
"  -- S for a string\n"
"  local function getargs(spec)\n"
"    local res={}\n"
"    local char,arg\n"
"    local ptr=1\n"
"    for i=1,string.len(spec) do\n"
"      char = string.sub(spec,i,i)\n"
"      if     char == 'F' then\n"
"        _,ptr,arg = string.find(args..' ',\"%s*([%w%p]*)%s*\",ptr)\n"
"        if not arg or arg == '' then arg = '-' end\n"
"        if arg == '-' then arg = breakfile end\n"
"      elseif char == 'L' then\n"
"        _,ptr,arg = string.find(args..' ',\"%s*([%w%p]*)%s*\",ptr)\n"
"        if not arg or arg == '' then arg = '-' end\n"
"        if arg == '-' then arg = breakline end\n"
"        arg = tonumber(arg) or 0\n"
"      elseif char == 'N' then\n"
"        _,ptr,arg = string.find(args..' ',\"%s*([%w%p]*)%s*\",ptr)\n"
"        if not arg or arg == '' then arg = '0' end\n"
"        arg = tonumber(arg) or 0\n"
"      elseif char == 'V' then\n"
"        _,ptr,arg = string.find(args..' ',\"%s*([%w%p]*)%s*\",ptr)\n"
"        if not arg or arg == '' then arg = '' end\n"
"      elseif char == 'S' then\n"
"        _,ptr,arg = string.find(args..' ',\"%s*([%w%p]*)%s*\",ptr)\n"
"        if not arg or arg == '' then arg = '' end\n"
"      else\n"
"        arg = ''\n"
"      end\n"
"      table.insert(res,arg or '')\n"
"    end\n"
"    return unpack(res)\n"
"  end\n"
"  --}}}\n"
"  while true do\n"
"    io.write(\"[DEBUG]> \")\n"
"    local line = io.read(\"*line\")\n"
"    if line == nil then io.write('\\n'); line = 'exit' end\n"
"    if line == \"\" then\n"
"        line = last_line\n"
"    else\n"
"        last_line = line\n"
"    end\n"
"    io.write(\"'\" .. last_line .. \"'\\n\")\n"
"    if string.find(line, \"^[a-z]+\") then\n"
"      command = string.sub(line, string.find(line, \"^[a-z]+\"))\n"
"      args    = string.gsub(line,\"^[a-z]+%s*\",'',1)            --strip command off line\n"
"    else\n"
"      command = ''\n"
"    end\n"
"    command = aliases[command] or command\n"
"    if command == \"setb\" then\n"
"      --{{{  set breakpoint\n"
"      local line, filename  = getargs('LF')\n"
"      if filename ~= '' and line ~= '' then\n"
"        set_breakpoint(filename,line)\n"
"        io.write(\"Breakpoint set in file \"..filename..' line '..line..'\\n')\n"
"      else\n"
"        io.write(\"Bad request\\n\")\n"
"      end\n"
"      --}}}\n"
"    elseif command == \"delb\" then\n"
"      --{{{  delete breakpoint\n"
"      local line, filename = getargs('LF')\n"
"      if filename ~= '' and line ~= '' then\n"
"        remove_breakpoint(filename, line)\n"
"        io.write(\"Breakpoint deleted from file \"..filename..' line '..line..\"\\n\")\n"
"      else\n"
"        io.write(\"Bad request\\n\")\n"
"      end\n"
"      --}}}\n"
"    elseif command == \"delallb\" then\n"
"      --{{{  delete all breakpoints\n"
"      breakpoints = {}\n"
"      io.write('All breakpoints deleted\\n')\n"
"      --}}}\n"
"    elseif command == \"listb\" then\n"
"      --{{{  list breakpoints\n"
"      for i, v in pairs(breakpoints) do\n"
"        for ii, vv in pairs(v) do\n"
"          io.write(\"Break at: \"..i..' in '..ii..'\\n')\n"
"        end\n"
"      end\n"
"      --}}}\n"
"    elseif command == \"setw\" then\n"
"      --{{{  set watch expression\n"
"      if args and args ~= '' then\n"
"        local func = loadstring(\"return(\" .. args .. \")\")\n"
"        local newidx = #watches + 1\n"
"        watches[newidx] = {func = func, exp = args}\n"
"        io.write(\"Set watch exp no. \" .. newidx..'\\n')\n"
"      else\n"
"        io.write(\"Bad request\\n\")\n"
"      end\n"
"      --}}}\n"
"    elseif command == \"delw\" then\n"
"      --{{{  delete watch expression\n"
"      local index = tonumber(args)\n"
"      if index then\n"
"        watches[index] = nil\n"
"        io.write(\"Watch expression deleted\\n\")\n"
"      else\n"
"        io.write(\"Bad request\\n\")\n"
"      end\n"
"      --}}}\n"
"    elseif command == \"delallw\" then\n"
"      --{{{  delete all watch expressions\n"
"      watches = {}\n"
"      io.write('All watch expressions deleted\\n')\n"
"      --}}}\n"
"    elseif command == \"listw\" then\n"
"      --{{{  list watch expressions\n"
"      for i, v in pairs(watches) do\n"
"        io.write(\"Watch exp. \" .. i .. \": \" .. v.exp..'\\n')\n"
"      end\n"
"      --}}}\n"
"    elseif command == \"run\" then\n"
"      --{{{  run until breakpoint\n"
"      step_into = false\n"
"      step_over = false\n"
"      return 'cont'\n"
"      --}}}\n"
"    elseif command == \"step\" then\n"
"      --{{{  step N lines (into functions)\n"
"      local N = tonumber(args) or 1\n"
"      step_over  = false\n"
"      step_into  = true\n"
"      step_lines = tonumber(N or 1)\n"
"      return 'cont'\n"
"      --}}}\n"
"    elseif command == \"over\" then\n"
"      --{{{  step N lines (over functions)\n"
"      local N = tonumber(args) or 1\n"
"      step_into  = false\n"
"      step_over  = true\n"
"      step_lines = tonumber(N or 1)\n"
"      step_level[current_thread] = stack_level[current_thread]\n"
"      return 'cont'\n"
"      --}}}\n"
"    elseif command == \"out\" then\n"
"      --{{{  step N lines (out of functions)\n"
"      local N = tonumber(args) or 1\n"
"      step_into  = false\n"
"      step_over  = true\n"
"      step_lines = 1\n"
"      step_level[current_thread] = stack_level[current_thread] - tonumber(N or 1)\n"
"      return 'cont'\n"
"      --}}}\n"
"    elseif command == \"gotoo\" then\n"
"      --{{{  step until reach line\n"
"      local line, filename = getargs('LF')\n"
"      if line ~= '' then\n"
"        step_over  = false\n"
"        step_into  = false\n"
"        if has_breakpoint(filename,line) then\n"
"          return 'cont'\n"
"        else\n"
"          set_breakpoint(filename,line,true)\n"
"          return 'cont'\n"
"        end\n"
"      else\n"
"        io.write(\"Bad request\\n\")\n"
"      end\n"
"      --}}}\n"
"    elseif command == \"set\" then\n"
"      --{{{  set/show context level\n"
"      local level = args\n"
"      if level and level == '' then level = nil end\n"
"      if level then return level end\n"
"      --}}}\n"
"    elseif command == \"vars\" then\n"
"      --{{{  list context variables\n"
"      local depth = args\n"
"      if depth and depth == '' then depth = nil end\n"
"      depth = tonumber(depth) or 1\n"
"      dumpvar(eval_env, depth+1, 'variables')\n"
"      --}}}\n"
"    elseif command == \"glob\" then\n"
"      --{{{  list global variables\n"
"      local depth = args\n"
"      if depth and depth == '' then depth = nil end\n"
"      depth = tonumber(depth) or 1\n"
"      dumpvar(eval_env.__GLOBALS__,depth+1,'globals')\n"
"      --}}}\n"
"    elseif command == \"fenv\" then\n"
"      --{{{  list function environment variables\n"
"      local depth = args\n"
"      if depth and depth == '' then depth = nil end\n"
"      depth = tonumber(depth) or 1\n"
"      dumpvar(eval_env.__ENVIRONMENT__,depth+1,'environment')\n"
"      --}}}\n"
"    elseif command == \"ups\" then\n"
"      --{{{  list upvalue names\n"
"      dumpvar(eval_env.__UPVALUES__,2,'upvalues')\n"
"      --}}}\n"
"    elseif command == \"locs\" then\n"
"      --{{{  list locals names\n"
"      dumpvar(eval_env.__LOCALS__,2,'upvalues')\n"
"      --}}}\n"
"    elseif command == \"what\" then\n"
"      --{{{  show where a function is defined\n"
"      if args and args ~= '' then\n"
"        local v = eval_env\n"
"        local n = nil\n"
"        for w in string.gmatch(args,\"[%w_]+\") do\n"
"          v = v[w]\n"
"          if n then n = n..'.'..w else n = w end\n"
"          if not v then break end\n"
"        end\n"
"        if type(v) == 'function' then\n"
"          local def = debug.getinfo(v,'S')\n"
"          if def then\n"
"            io.write(def.what..' in '..def.short_src..' '..def.linedefined..'..'..def.lastlinedefined..'\\n')\n"
"          else\n"
"            io.write('Cannot get info for '..v..'\\n')\n"
"          end\n"
"        else\n"
"          io.write(v..' is not a function\\n')\n"
"        end\n"
"      else\n"
"        io.write(\"Bad request\\n\")\n"
"      end\n"
"      --}}}\n"
"    elseif command == \"dump\" then\n"
"      --{{{  dump a variable\n"
"      local name, depth = getargs('VN')\n"
"      if name ~= '' then\n"
"        if depth == '' or depth == 0 then depth = nil end\n"
"        depth = tonumber(depth or 1)\n"
"        local v = eval_env\n"
"        local n = nil\n"
"        for w in string.gmatch(name,\"[^%.]+\") do     --get everything between dots\n"
"          if tonumber(w) then\n"
"            v = v[tonumber(w)]\n"
"          else\n"
"            v = v[w]\n"
"          end\n"
"          if n then n = n..'.'..w else n = w end\n"
"          if not v then break end\n"
"        end\n"
"        dumpvar(v,depth+1,n)\n"
"      else\n"
"        io.write(\"Bad request\\n\")\n"
"      end\n"
"      --}}}\n"
"    elseif command == \"show\" then\n"
"      --{{{  show file around a line or the current breakpoint\n"
"      local line, file, before, after = getargs('LFNN')\n"
"      if before == 0 then before = 10     end\n"
"      if after  == 0 then after  = before end\n"
"      if file ~= '' and file ~= \"=stdin\" then\n"
"        show(file,line,before,after)\n"
"      else\n"
"        io.write('Nothing to show\\n')\n"
"      end\n"
"      --}}}\n"
"    elseif command == \"poff\" then\n"
"      --{{{  turn pause command off\n"
"      pause_off = true\n"
"      --}}}\n"
"    elseif command == \"pon\" then\n"
"      --{{{  turn pause command on\n"
"      pause_off = false\n"
"      --}}}\n"
"    elseif command == \"tron\" then\n"
"      --{{{  turn tracing on/off\n"
"      local option = getargs('S')\n"
"      trace_calls   = false\n"
"      trace_returns = false\n"
"      trace_lines   = false\n"
"      if string.find(option,'c') then trace_calls   = true end\n"
"      if string.find(option,'r') then trace_returns = true end\n"
"      if string.find(option,'l') then trace_lines   = true end\n"
"      --}}}\n"
"    elseif command == \"trace\" then\n"
"      --{{{  dump a stack trace\n"
"      trace(eval_env.__VARSLEVEL__)\n"
"      --}}}\n"
"    elseif command == \"info\" then\n"
"      --{{{  dump all debug info captured\n"
"      info()\n"
"      --}}}\n"
"    elseif command == \"pause\" then\n"
"      --{{{  not allowed in here\n"
"      io.write('pause() should only be used in the script you are debugging\\n')\n"
"      --}}}\n"
"    elseif command == \"help\" then\n"
"      --{{{  help\n"
"      local command = getargs('S')\n"
"      if command ~= '' and hints[command] then\n"
"        io.write(hints[command]..'\\n')\n"
"      else\n"
"        for _,v in pairs(hints) do\n"
"          local _,_,h = string.find(v,\"(.+)|\")\n"
"          io.write(h..'\\n')\n"
"        end\n"
"      end\n"
"      --}}}\n"
"    elseif command == \"exit\" then\n"
"      --{{{  exit debugger\n"
"      return 'stop'\n"
"      --}}}\n"
"    elseif line ~= '' then\n"
"      --{{{  just execute whatever it is in the current context\n"
"      --map line starting with \"=...\" to \"return ...\"\n"
"      if string.sub(line,1,1) == '=' then line = string.gsub(line,'=','return ',1) end\n"
"      local ok, func = pcall(loadstring,line)\n"
"      if func == nil then                             --Michael.Bringmann@lsi.com\n"
"        io.write(\"Compile error: \"..line..'\\n')\n"
"      elseif not ok then\n"
"        io.write(\"Compile error: \"..func..'\\n')\n"
"      else\n"
"        setfenv(func, eval_env)\n"
"        local res = {pcall(func)}\n"
"        if res[1] then\n"
"          if res[2] then\n"
"            table.remove(res,1)\n"
"            for _,v in ipairs(res) do\n"
"              io.write(tostring(v))\n"
"              io.write('\\t')\n"
"            end\n"
"            io.write('\\n')\n"
"          end\n"
"          --update in the context\n"
"          return 0\n"
"        else\n"
"          io.write(\"Run error: \"..res[2]..'\\n')\n"
"        end\n"
"      end\n"
"      --}}}\n"
"    end\n"
"  end\n"
"end\n"
"local function debug_hook(event, line, level, thread)\n"
"  if not started then debug.sethook(); coro_debugger = nil; return end\n"
"  current_thread = thread or 'main'\n"
"  local level = level or 2\n"
"  trace_event(event,line,level)\n"
"  if event == \"call\" then\n"
"    stack_level[current_thread] = stack_level[current_thread] + 1\n"
"  elseif event == \"return\" then\n"
"    stack_level[current_thread] = stack_level[current_thread] - 1\n"
"    if stack_level[current_thread] < 0 then stack_level[current_thread] = 0 end\n"
"  else\n"
"    local vars,file,line = capture_vars(level,1,line)\n"
"    local stop, ev, idx = false, events.STEP, 0\n"
"    while true do\n"
"      for index, value in pairs(watches) do\n"
"        setfenv(value.func, vars)\n"
"        local status, res = pcall(value.func)\n"
"        if status and res then\n"
"          ev, idx = events.WATCH, index\n"
"          stop = true\n"
"          break\n"
"        end\n"
"      end\n"
"      if stop then break end\n"
"      if (step_into)\n"
"      or (step_over and (stack_level[current_thread] <= step_level[current_thread] or stack_level[current_thread] == 0)) then\n"
"        step_lines = step_lines - 1\n"
"        if step_lines < 1 then\n"
"          ev, idx = events.STEP, 0\n"
"          break\n"
"        end\n"
"      end\n"
"      if has_breakpoint(file, line) then\n"
"        ev, idx = events.BREAK, 0\n"
"        break\n"
"      end\n"
"      return\n"
"    end\n"
"    tracestack(level)\n"
"    if not coro_debugger then\n"
"      io.write(\"\\nLua Debugger\\n\")\n"
"      vars, file, line = report(ev, vars, file, line, idx)\n"
"      io.write(\"Type 'help' for commands\\n\")\n"
"      coro_debugger = true\n"
"    else\n"
"      vars, file, line = report(ev, vars, file, line, idx)\n"
"    end\n"
"    local last_next = 1\n"
"    local next = 'ask'\n"
"    local silent = false\n"
"    while true do\n"
"      if next == 'ask' then\n"
"        next = debugger_loop(ev, vars, file, line, idx)\n"
"      elseif next == 'cont' then\n"
"        return\n"
"      elseif next == 'stop' then\n"
"        started = false\n"
"        debug.sethook()\n"
"        coro_debugger = nil\n"
"        return\n"
"      elseif tonumber(next) then --get vars for given level or last level\n"
"        next = tonumber(next)\n"
"        if next == 0 then silent = true; next = last_next else silent = false end\n"
"        last_next = next\n"
"        restore_vars(level,vars)\n"
"        vars, file, line = capture_vars(level,next)\n"
"        if not silent then\n"
"          if vars and vars.__VARSLEVEL__ then\n"
"            io.write('Level: '..vars.__VARSLEVEL__..'\\n')\n"
"          else\n"
"            io.write('No level set\\n')\n"
"          end\n"
"        end\n"
"        ev = events.SET\n"
"        next = 'ask'\n"
"      else\n"
"        io.write('Unknown command from debugger_loop: '..tostring(next)..'\\n')\n"
"        io.write('Stopping debugger\\n')\n"
"        next = 'stop'\n"
"      end\n"
"    end\n"
"  end\n"
"end\n"
"_G.coroutine.create = function(f)\n"
"  local thread\n"
"  local hook, mask, count = debug.gethook()\n"
"  if hook then\n"
"    local function thread_hook(event,line)\n"
"      hook(event,line,3,thread)\n"
"    end\n"
"    thread = cocreate(function(...)\n"
"                        stack_level[thread] = 0\n"
"                        trace_level[thread] = 0\n"
"                        step_level [thread] = 0\n"
"                        debug.sethook(thread_hook,mask,count)\n"
"                        return f(...)\n"
"                      end)\n"
"    return thread\n"
"  else\n"
"    return cocreate(f)\n"
"  end\n"
"end\n"
"_G.coroutine.wrap = function(f)\n"
"  local thread\n"
"  local hook, mask, count = debug.gethook()\n"
"  if hook then\n"
"    local function thread_hook(event,line)\n"
"      hook(event,line,3,thread)\n"
"    end\n"
"    thread = cowrap(function(...)\n"
"                      stack_level[thread] = 0\n"
"                      trace_level[thread] = 0\n"
"                      step_level [thread] = 0\n"
"                      debug.sethook(thread_hook,mask,count)\n"
"                      return f(...)\n"
"                    end)\n"
"    return thread\n"
"  else\n"
"    return cowrap(f)\n"
"  end\n"
"end\n"
"function pause(x,l,f)\n"
"  if not f and pause_off then return end       --being told to ignore pauses\n"
"  pausemsg = x or 'pause'\n"
"  local lines\n"
"  local src = getinfo(2,'short_src')\n"
"  if l then\n"
"    lines = l   --being told when to stop\n"
"  elseif src == \"stdin\" then\n"
"    lines = 1   --if in a console session, stop now\n"
"  else\n"
"    lines = 2   --if in a script, stop when get out of pause()\n"
"  end\n"
"  if started then\n"
"    --we'll stop now 'cos the existing debug hook will grab us\n"
"    step_lines = lines\n"
"    step_into  = true\n"
"    debug.sethook(debug_hook, \"crl\")         --reset it in case some external agent fiddled with it\n"
"  else\n"
"    --set to stop when get out of pause()\n"
"    trace_level[current_thread] = 0\n"
"    step_level [current_thread] = 0\n"
"    stack_level[current_thread] = 1\n"
"    step_lines = lines\n"
"    step_into  = true\n"
"    started    = true\n"
"    debug.sethook(debug_hook, \"crl\")         --NB: this will cause an immediate entry to the debugger_loop\n"
"  end\n"
"end\n"
"function dump(v,depth)\n"
"  dumpvar(v,(depth or 1)+1,tostring(v))\n"
"end\n"
"local _traceback = debug.traceback       --note original function\n"
"debug.traceback = function(x)\n"
"  local assertmsg = _traceback(x)        --do original function\n"
"  pause(x)                               --let user have a look at stuff\n"
"  return assertmsg                       --carry on\n"
"end\n"
"_TRACEBACK = debug.traceback             --Lua 5.0 function\n"
"";const char* lib_lua_scripts[] = {lib_clink_lua_script,lib_match_lua_script,lib_arguments_lua_script,lib_debugger_lua_script,nullptr,};
#else
const char* lib_embed_path = __FILE__;
const char* lib_clink_lua_file = "clink.lua";
const char* lib_match_lua_file = "match.lua";
const char* lib_arguments_lua_file = "arguments.lua";
const char* lib_debugger_lua_file = "debugger.lua";
const char* lib_lua_files[] = {lib_clink_lua_file,lib_match_lua_file,lib_arguments_lua_file,lib_debugger_lua_file,nullptr,};
#endif
