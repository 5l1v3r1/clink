#include "pch.h"
#if defined(CLINK_FINAL)
const char* app_cmd_lua_script = 
"local cmd_module = clink:module(40)\n"
"local cmd_commands = {\n"
"    \"assoc\", \"break\", \"call\", \"cd\", \"chcp\", \"chdir\", \"cls\", \"color\", \"copy\",\n"
"    \"date\", \"del\", \"dir\", \"diskcomp\", \"diskcopy\", \"echo\", \"endlocal\", \"erase\",\n"
"    \"exit\", \"for\", \"format\", \"ftype\", \"goto\", \"graftabl\", \"if\", \"md\", \"mkdir\",\n"
"    \"mklink\", \"more\", \"move\", \"path\", \"pause\", \"popd\", \"prompt\", \"pushd\", \"rd\",\n"
"    \"rem\", \"ren\", \"rename\", \"rmdir\", \"set\", \"setlocal\", \"shift\", \"start\",\n"
"    \"time\", \"title\", \"tree\", \"type\", \"ver\", \"verify\", \"vol\"\n"
"}\n"
"function cmd_module:generate(line_state, match_builder)\n"
"    -- Cmd commands only apply for the first word of a line.\n"
"    if line_state:getwordcount() > 1 then\n"
"        return false\n"
"    end\n"
"    -- They should be skipped if the the line's whitespace prefixed.\n"
"    if settings.get(\"exec.space_prefix\") then\n"
"        local word_info = line_state:getwordinfo(1)\n"
"        local offset = line_state:getcommandoffset()\n"
"        if word_info.quoted then offset = offset + 1 end\n"
"        if word_info.offset > offset then\n"
"            return false\n"
"        end\n"
"    end\n"
"    -- If the word being completed is a relative path then commands don't apply.\n"
"    local text = line_state:getword(1)\n"
"    local text_dir = path.getdirectory(text) or \"\"\n"
"    if #text_dir ~= 0 then\n"
"        return false\n"
"    end\n"
"    match_builder:addmatches(cmd_commands)\n"
"    return false\n"
"end\n"
"";const char* app_dir_lua_script = 
"clink:argmatcher(\"cd\", \"chdir\", \"pushd\", \"rd\", \"rmdir\", \"md\", \"mkdir\"):addarg(\n"
"    function (word_index, line_state)\n"
"        local word = line_state:getword(word_index)\n"
"        local matches = {}\n"
"        for _, dir in ipairs(os.globdirs(word..\"*\")) do\n"
"            table.insert(matches, dir)\n"
"        end\n"
"        return matches\n"
"    end\n"
")\n"
"";const char* app_env_lua_script = 
"local envvar_module = clink.module(10)\n"
"local special_env_vars = {\n"
"    \"cd\", \"date\", \"time\", \"random\", \"errorlevel\",\n"
"    \"cmdextversion\", \"cmdcmdline\", \"highestnumanodenumber\"\n"
"}\n"
"local function env_vars_display_filter(matches)\n"
"    local to_display = {}\n"
"    for _, m in ipairs(matches) do\n"
"        local _, _, out = m:find(\"(%%[^%%]+%%)$\")\n"
"        table.insert(to_display, out)\n"
"    end\n"
"    return to_display\n"
"end\n"
"local function env_vars_find_matches(candidates, prefix, part, result)\n"
"    for _, name in ipairs(candidates) do\n"
"        result:addmatch(prefix..'%'..name:lower()..'%')\n"
"    end\n"
"end\n"
"local function env_vars_match_generator(text, first, last, result)\n"
"    local all = line_state.line:sub(1, last)\n"
"    -- Skip pairs of %s\n"
"    local i = 1\n"
"    for _, r in function () return all:find(\"%b%%\", i) end do\n"
"        i = r + 2\n"
"    end\n"
"    -- Find a solitary %\n"
"    local i = all:find(\"%%\", i)\n"
"    if not i then\n"
"        return false\n"
"    end\n"
"    if i < first then\n"
"        return false\n"
"    end\n"
"    local part = clink.lower(all:sub(i + 1))\n"
"    i = i - first\n"
"    local prefix = text:sub(1, i)\n"
"    env_vars_find_matches(os.getenvnames(), prefix, part, result)\n"
"    env_vars_find_matches(special_env_vars, prefix, part, result)\n"
"    if result:getmatchcount() >= 1 then\n"
"        clink.match_display_filter = env_vars_display_filter\n"
"        return true\n"
"    end\n"
"    return false\n"
"end\n"
"";const char* app_exec_lua_script = 
"settings.add(\"exec.enable\", true, \"Enable executable matching\",\n"
"\"Only match executables when completing the first word of a line\")\n"
"settings.add(\"exec.path\", true, \"Match executables in PATH\",\n"
"[[Completes execuables found in the directories specified in the PATH\n"
"environment system variable.]])\n"
"settings.add(\"exec.cwd\", false, \"Match executables in current directory\",\n"
"[[Include executables in the current directory. This is implicit if the word\n"
"being completed is a relative path.]])\n"
"settings.add(\"exec.dirs\", true, \"Include directories\",\n"
"\"Include directories relative to the current working directory as matches.\")\n"
"settings.add(\"exec.space_prefix\", true, \"Whitespace prefix matches files\",\n"
"[[If the line begins with whitespace then Clink bypasses executable\n"
"matching and will do normal files matching instead.]])\n"
"local function get_environment_paths()\n"
"    local paths = os.getenv(\"path\"):explode(\";\")\n"
"    -- Append slashes.\n"
"    for i = 1, #paths, 1 do\n"
"        paths[i] = paths[i]..\"/\"\n"
"    end\n"
"    return paths\n"
"end\n"
"local function exec_find_dirs(pattern, case_map)\n"
"    local ret = {}\n"
"    for _, dir in ipairs(clink.find_dirs(pattern, case_map)) do\n"
"        if dir ~= \".\" and dir ~= \"..\" then\n"
"            table.insert(ret, dir)\n"
"        end\n"
"    end\n"
"    return ret\n"
"end\n"
"local exec_module = clink:module(50)\n"
"function exec_module:generate(line_state, match_builder)\n"
"    -- If executable matching is disabled do nothing\n"
"    if not settings.get(\"exec.enable\") then\n"
"        return false\n"
"    end\n"
"    -- We're only interested in exec completion if this is the first word of\n"
"    -- the line.\n"
"    if line_state:getwordcount() > 1 then\n"
"        return false\n"
"    end\n"
"    -- If enabled, lines prefixed with whitespace disable executable matching.\n"
"    if settings.get(\"exec.space_prefix\") then\n"
"        local word_info = line_state:getwordinfo(1)\n"
"        local offset = line_state:getcommandoffset()\n"
"        if word_info.quoted then offset = offset + 1 end\n"
"        if word_info.offset > offset then\n"
"            return false\n"
"        end\n"
"    end\n"
"    -- Settings that control what matches are generated.\n"
"    local match_dirs = settings.get(\"exec.dirs\")\n"
"    local match_cwd = settings.get(\"exec.cwd\")\n"
"    local paths = nil\n"
"    local text = line_state:getword(1)\n"
"    local text_dir = path.getdirectory(text) or \"\"\n"
"    if #text_dir == 0 then\n"
"        -- Add console aliases as matches.\n"
"        local aliases = os.getaliases()\n"
"        match_builder:addmatches(aliases)\n"
"        -- Add environment's PATH variable as paths to search.\n"
"        if settings.get(\"exec.path\") then\n"
"            paths = get_environment_paths()\n"
"        end\n"
"    else\n"
"        -- 'text' is an absolute or relative path so override settings and\n"
"        -- match current directory and its directories too.\n"
"        match_dirs = true\n"
"        match_cwd = true\n"
"    end\n"
"    if not paths then\n"
"        paths = {}\n"
"    end\n"
"    -- Should we also consider the path referenced by 'text'?\n"
"    if match_cwd then\n"
"        table.insert(paths, text)\n"
"    end\n"
"    -- Search 'paths' for files ending in 'suffices' and look for matches\n"
"    local added = false\n"
"    local suffices = os.getenv(\"pathext\"):explode(\";\")\n"
"    for _, suffix in ipairs(suffices) do\n"
"        for _, dir in ipairs(paths) do\n"
"            for _, file in ipairs(os.globfiles(dir..\"*\"..suffix)) do\n"
"                added = match_builder:addmatch(file) or added\n"
"            end\n"
"        end\n"
"    end\n"
"    -- Lastly we may wish to consider directories too.\n"
"    if match_dirs or not added then\n"
"        match_builder:addmatches(os.globdirs(text..\"*\"))\n"
"    end\n"
"    return true\n"
"end\n"
"";const char* app_powershell_lua_script = 
"local powershell_prompt = clink:promptfilter(-493)\n"
"function powershell_prompt:filter(prompt)\n"
"    local l, r, path = prompt:find(\"([a-zA-Z]:\\\\.*)> $\")\n"
"    if path ~= nil then\n"
"        os.chdir(path)\n"
"    end\n"
"end\n"
"";const char* app_prompt_lua_script = 
"clink._prompt_filters = {}\n"
"function clink:promptfilter(priority)\n"
"    if priority == nil then priority = 999 end\n"
"    local ret = { _priority = priority }\n"
"    table.insert(self._prompt_filters, ret)\n"
"    return ret\n"
"end\n"
"function clink:_filter_prompt_impl(prompt)\n"
"    for _, filter in ipairs(self._prompt_filters) do\n"
"        local filtered, onwards = filter:filter(prompt)\n"
"        if filtered ~= nil then\n"
"            if onwards == false then return filtered end\n"
"            prompt = filtered\n"
"        end\n"
"    end\n"
"    return prompt\n"
"end\n"
"function clink:_filter_prompt(prompt)\n"
"    -- Sort by priority if required.\n"
"    if self._prompt_filters_unsorted then\n"
"        local lambda = function(a, b) return a._priority < b._priority end\n"
"        table.sort(self._prompt_filters, lambda)\n"
"        self._prompt_filters_unsorted = false\n"
"    end\n"
"    -- Protected call to prompt filters.\n"
"    local ok, ret = pcall(self._filter_prompt_impl, self, prompt)\n"
"    if not ok then\n"
"        print(\"\")\n"
"        print(ret)\n"
"        print(debug.traceback())\n"
"        return false\n"
"    end\n"
"    return ret\n"
"end\n"
"";const char* app_self_lua_script = 
"local nothing = clink:argmatcher()\n"
"local inject = clink:argmatcher()\n"
":addflags(\"--help\", \"--pid\", \"--profile\", \"--quiet\", \"--nolog\")\n"
"local autorun_dashdash = clink:argmatcher()\n"
":addarg(\"--\" .. inject)\n"
"local autorun = clink:argmatcher()\n"
":addflags(\"--allusers\", \"--help\")\n"
":addarg(\n"
"    \"install\"   .. autorun_dashdash,\n"
"    \"uninstall\" .. nothing,\n"
"    \"show\"      .. nothing,\n"
"    \"set\"\n"
")\n"
"local function set_handler(word_index, line_state)\n"
"    local ret = {}\n"
"    local name = line_state:getword(word_index) or \"\"\n"
"    local cmd = io.popen(CLINK_EXE..\" set --list \"..name, \"r\")\n"
"    for line in cmd:lines() do\n"
"        table.insert(ret, line)\n"
"    end\n"
"    return ret\n"
"end\n"
"local set = clink:argmatcher()\n"
":addflags(\"--help\")\n"
":addarg(set_handler)\n"
":addarg(set_handler)\n"
"local history = clink:argmatcher()\n"
":addflags(\"--help\")\n"
":addarg(\n"
"    \"add\",\n"
"    \"clear\"     .. nothing,\n"
"    \"delete\"    .. nothing,\n"
"    \"expand\"\n"
")\n"
"clink:argmatcher(\n"
"    \"clink\",\n"
"    \"clink_x86.exe\",\n"
"    \"clink_x64.exe\")\n"
":addarg(\n"
"    \"autorun\"   .. autorun,\n"
"    \"echo\"      .. nothing,\n"
"    \"history\"   .. history,\n"
"    \"inject\"    .. inject,\n"
"    \"set\"       .. set\n"
")\n"
"";const char* app_set_lua_script = 
"clink:argmatcher(\"set\"):addarg(\n"
"    function ()\n"
"        local ret = {}\n"
"        for _, i in ipairs(os.getenvnames()) do\n"
"            table.insert(ret, { match = i, suffix = \"=\" })\n"
"        end\n"
"        return ret\n"
"    end\n"
")\n"
"";const char* app_lua_scripts[] = {app_cmd_lua_script,app_dir_lua_script,app_env_lua_script,app_exec_lua_script,app_powershell_lua_script,app_prompt_lua_script,app_self_lua_script,app_set_lua_script,nullptr,};
#else
const char* app_cmd_lua_file = CLINK_BUILD_ROOT "/../../clink/app/scripts/cmd.lua";
const char* app_dir_lua_file = CLINK_BUILD_ROOT "/../../clink/app/scripts/dir.lua";
const char* app_env_lua_file = CLINK_BUILD_ROOT "/../../clink/app/scripts/env.lua";
const char* app_exec_lua_file = CLINK_BUILD_ROOT "/../../clink/app/scripts/exec.lua";
const char* app_powershell_lua_file = CLINK_BUILD_ROOT "/../../clink/app/scripts/powershell.lua";
const char* app_prompt_lua_file = CLINK_BUILD_ROOT "/../../clink/app/scripts/prompt.lua";
const char* app_self_lua_file = CLINK_BUILD_ROOT "/../../clink/app/scripts/self.lua";
const char* app_set_lua_file = CLINK_BUILD_ROOT "/../../clink/app/scripts/set.lua";
const char* app_lua_files[] = {app_cmd_lua_file,app_dir_lua_file,app_env_lua_file,app_exec_lua_file,app_powershell_lua_file,app_prompt_lua_file,app_self_lua_file,app_set_lua_file,nullptr,};
#endif
