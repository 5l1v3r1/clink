diff --git a/readline/readline/complete.c b/readline/readline/complete.c
index e67cfeb..22b7176 100644
--- a/readline/readline/complete.c
+++ b/readline/readline/complete.c
@@ -2333,9 +2333,15 @@ rl_filename_completion_function (text, state)
 	      dirlen = strlen (users_dirname);
 	      temp = (char *)xmalloc (2 + dirlen + D_NAMLEN (entry));
 	      strcpy (temp, users_dirname);
+/* begin_clink_change
+ * Removed appending of a '/' to correctly support volume-relative paths.
+ */
+#if 0
 	      /* Make sure that temp has a trailing slash here. */
 	      if (users_dirname[dirlen - 1] != '/')
 		temp[dirlen++] = '/';
+#endif
+/* end_clink_change */
 	    }
 
 	  strcpy (temp + dirlen, convfn);
diff --git a/readline/readline/complete.c b/readline/readline/complete.c
index 0aec9c1..e5ce3e2 100644
--- a/readline/readline/complete.c
+++ b/readline/readline/complete.c
@@ -933,6 +933,14 @@ _rl_find_completion_word (fp, dp)
       /* FOUND_QUOTE is set so we know what kind of quotes we found. */
       for (scan = pass_next = 0; scan < end; scan = MB_NEXTCHAR (rl_line_buffer, scan, 1, MB_FIND_ANY))
 	{
+/* begin_clink_change
+ * The following assumes we want to use backslashes to escape the next
+ * character. This doesn't apply on Windows as a \ is the part separator. Removing
+ * this code stops strings like the following getting misunderstood by readline;
+ *
+ * c:\>foobar.bat "c:\Program Files\"
+ */
+#if 0
 	  if (pass_next)
 	    {
 	      pass_next = 0;
@@ -949,6 +957,8 @@ _rl_find_completion_word (fp, dp)
 	      found_quote |= RL_QF_BACKSLASH;
 	      continue;
 	    }
+#endif
+/* end_clink_change */
 
 	  if (quote_char != '\0')
 	    {
diff --git a/readline/readline/bind.c b/readline/readline/bind.c
index 59e7964..1b12df1 100644
--- a/readline/readline/bind.c
+++ b/readline/readline/bind.c
@@ -1106,6 +1106,17 @@ parser_include (args)
 
   return r;
 }
+
+/* begin_clink_change
+ * MSVC has issue with "int foo(bar) char* bar; { ... } syntax. It considers the
+ * function to have no arguments and complains when assigning function pointer
+ * to a variable. The workaround is to forward declare them _before_ assignment.
+ */
+int parser_if(char*);
+int parser_endif(char*);
+int parser_else(char*);
+int parser_include(char*);
+/* end_clink_change */
   
 /* Associate textual names with actual functions. */
 static const struct {
diff --git a/readline/readline/signals.c b/readline/readline/signals.c
index 6a68d78..faf7803 100644
--- a/readline/readline/signals.c
+++ b/readline/readline/signals.c
@@ -64,7 +64,12 @@
 
 /* This typedef is equivalent to the one for Function; it allows us
    to say SigHandler *foo = signal (SIGKILL, SIG_IGN); */
-typedef RETSIGTYPE SigHandler ();
+/* begin_clink_change
+ * Address MSVC compiler warnings. signal() returns type "void (*)(int)".
+ */
+//typedef RETSIGTYPE SigHandler ();
+typedef RETSIGTYPE SigHandler (int);
+/* end_clink_change */
 
 #if defined (HAVE_POSIX_SIGNALS)
 typedef struct sigaction sighandler_cxt;
diff --git a/readline/readline/input.c b/readline/readline/input.c
index 7c74c99..e59bad6 100644
--- a/readline/readline/input.c
+++ b/readline/readline/input.c
@@ -169,7 +169,12 @@ rl_gather_tyi ()
   int tty;
   register int tem, result;
   int chars_avail, k;
-  char input;
+/* begin_clink_change
+ * MSVC compile error
+ */
+  //char input;
+  char input = 0;
+/* end_clink_change */
 #if defined(HAVE_SELECT)
   fd_set readfds, exceptfds;
   struct timeval timeout;
diff --git a/readline/readline/bind.c b/readline/readline/bind.c
index 1b12df1..4c898a6 100644
--- a/readline/readline/bind.c
+++ b/readline/readline/bind.c
@@ -1112,10 +1112,12 @@ parser_include (args)
  * function to have no arguments and complains when assigning function pointer
  * to a variable. The workaround is to forward declare them _before_ assignment.
  */
+#ifdef _MSC_VER
 int parser_if(char*);
 int parser_endif(char*);
 int parser_else(char*);
 int parser_include(char*);
+#endif
 /* end_clink_change */
   
 /* Associate textual names with actual functions. */
