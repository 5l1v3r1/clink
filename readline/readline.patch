diff --git a/readline/readline/complete.c b/readline/readline/complete.c
index e67cfeb..22b7176 100644
--- a/readline/readline/complete.c
+++ b/readline/readline/complete.c
@@ -2333,9 +2333,15 @@ rl_filename_completion_function (text, state)
 	      dirlen = strlen (users_dirname);
 	      temp = (char *)xmalloc (2 + dirlen + D_NAMLEN (entry));
 	      strcpy (temp, users_dirname);
+/* begin_clink_change
+ * Removed appending of a '/' to correctly support volume-relative paths.
+ */
+#if 0
 	      /* Make sure that temp has a trailing slash here. */
 	      if (users_dirname[dirlen - 1] != '/')
 		temp[dirlen++] = '/';
+#endif
+/* end_clink_change */
 	    }
 
 	  strcpy (temp + dirlen, convfn);
diff --git a/readline/readline/complete.c b/readline/readline/complete.c
index 0aec9c1..e5ce3e2 100644
--- a/readline/readline/complete.c
+++ b/readline/readline/complete.c
@@ -933,6 +933,14 @@ _rl_find_completion_word (fp, dp)
       /* FOUND_QUOTE is set so we know what kind of quotes we found. */
       for (scan = pass_next = 0; scan < end; scan = MB_NEXTCHAR (rl_line_buffer, scan, 1, MB_FIND_ANY))
 	{
+/* begin_clink_change
+ * The following assumes we want to use backslashes to escape the next
+ * character. This doesn't apply on Windows as a \ is the part separator. Removing
+ * this code stops strings like the following getting misunderstood by readline;
+ *
+ * c:\>foobar.bat "c:\Program Files\"
+ */
+#if 0
 	  if (pass_next)
 	    {
 	      pass_next = 0;
@@ -949,6 +957,8 @@ _rl_find_completion_word (fp, dp)
 	      found_quote |= RL_QF_BACKSLASH;
 	      continue;
 	    }
+#endif
+/* end_clink_change */
 
 	  if (quote_char != '\0')
 	    {
diff --git a/readline/readline/bind.c b/readline/readline/bind.c
index 59e7964..1b12df1 100644
--- a/readline/readline/bind.c
+++ b/readline/readline/bind.c
@@ -1106,6 +1106,17 @@ parser_include (args)
 
   return r;
 }
+
+/* begin_clink_change
+ * MSVC has issue with "int foo(bar) char* bar; { ... } syntax. It considers the
+ * function to have no arguments and complains when assigning function pointer
+ * to a variable. The workaround is to forward declare them _before_ assignment.
+ */
+int parser_if(char*);
+int parser_endif(char*);
+int parser_else(char*);
+int parser_include(char*);
+/* end_clink_change */
   
 /* Associate textual names with actual functions. */
 static const struct {
diff --git a/readline/readline/signals.c b/readline/readline/signals.c
index 6a68d78..faf7803 100644
--- a/readline/readline/signals.c
+++ b/readline/readline/signals.c
@@ -64,7 +64,12 @@
 
 /* This typedef is equivalent to the one for Function; it allows us
    to say SigHandler *foo = signal (SIGKILL, SIG_IGN); */
-typedef RETSIGTYPE SigHandler ();
+/* begin_clink_change
+ * Address MSVC compiler warnings. signal() returns type "void (*)(int)".
+ */
+//typedef RETSIGTYPE SigHandler ();
+typedef RETSIGTYPE SigHandler (int);
+/* end_clink_change */
 
 #if defined (HAVE_POSIX_SIGNALS)
 typedef struct sigaction sighandler_cxt;
diff --git a/readline/readline/input.c b/readline/readline/input.c
index 7c74c99..e59bad6 100644
--- a/readline/readline/input.c
+++ b/readline/readline/input.c
@@ -169,7 +169,12 @@ rl_gather_tyi ()
   int tty;
   register int tem, result;
   int chars_avail, k;
-  char input;
+/* begin_clink_change
+ * MSVC compile error
+ */
+  //char input;
+  char input = 0;
+/* end_clink_change */
 #if defined(HAVE_SELECT)
   fd_set readfds, exceptfds;
   struct timeval timeout;
diff --git a/readline/readline/bind.c b/readline/readline/bind.c
index 1b12df1..4c898a6 100644
--- a/readline/readline/bind.c
+++ b/readline/readline/bind.c
@@ -1112,10 +1112,12 @@ parser_include (args)
  * function to have no arguments and complains when assigning function pointer
  * to a variable. The workaround is to forward declare them _before_ assignment.
  */
+#ifdef _MSC_VER
 int parser_if(char*);
 int parser_endif(char*);
 int parser_else(char*);
 int parser_include(char*);
+#endif
 /* end_clink_change */
   
 /* Associate textual names with actual functions. */
diff --git a/readline/readline/complete.c b/readline/readline/complete.c
index e5ce3e2..3ed21cc 100644
--- a/readline/readline/complete.c
+++ b/readline/readline/complete.c
@@ -2031,7 +2031,12 @@ rl_username_completion_function (text, state)
      const char *text;
      int state;
 {
-#if defined (__WIN32__) || defined (__OPENNT)
+/*
+ * begin_clink_change
+ * Disable username completion.
+ */
+#if defined (__WIN32__) || defined (__OPENNT) || 1
+/* end_clink_change */
   return (char *)NULL;
 #else /* !__WIN32__ && !__OPENNT) */
   static char *username = (char *)NULL;
diff --git a/readline/readline/rldefs.h b/readline/readline/rldefs.h
index 0257754..e211213 100644
--- a/readline/readline/rldefs.h
+++ b/readline/readline/rldefs.h
@@ -40,7 +40,11 @@
 #  if defined (HAVE_TERMIO_H)
 #    define TERMIO_TTY_DRIVER
 #  else
-#    if !defined (__MINGW32__)
+/* begin_clink_change
+ * Ensure NO_TTY_DRIVER is defined
+ */
+#    if !defined (__MINGW32__) && 0
+/* end_clink_change */
 #      define NEW_TTY_DRIVER
 #    else
 #      define NO_TTY_DRIVER
diff --git a/readline/readline/vi_mode.c b/readline/readline/vi_mode.c
index 41e1dbb..4743444 100644
--- a/readline/readline/vi_mode.c
+++ b/readline/readline/vi_mode.c
@@ -677,6 +677,12 @@ int
 rl_vi_insertion_mode (count, key)
      int count, key;
 {
+/* begin_clink_change
+ * Change cursor appearance to reflect vi edit mode
+ */
+  _rl_set_cursor(RL_IM_INSERT, 1);
+/* end_clink_change */
+
   _rl_keymap = vi_insertion_keymap;
   _rl_vi_last_key_before_insert = key;
   return (0);
@@ -718,6 +724,11 @@ _rl_vi_save_insert (up)
 void
 _rl_vi_done_inserting ()
 {
+/* begin_clink_change
+ * Change cursor appearance to reflect vi edit mode
+ */
+  _rl_set_cursor(RL_IM_OVERWRITE, 1);
+/* end_clink_change */
   if (_rl_vi_doing_insert)
     {
       /* The `C', `s', and `S' commands set this. */
@@ -1909,6 +1920,12 @@ rl_vi_replace (count, key)
 {
   int i;
 
+/* begin_clink_change
+ * Change cursor appearance to reflect vi edit mode
+ */
+  _rl_set_cursor(RL_IM_INSERT, 1);
+/* end_clink_change */
+
   vi_replace_count = 0;
 
   if (!vi_replace_map)
