diff --git a/readline/readline/complete.c b/readline/readline/complete.c
index e67cfeb..22b7176 100644
--- a/readline/readline/complete.c
+++ b/readline/readline/complete.c
@@ -2333,9 +2333,15 @@ rl_filename_completion_function (text, state)
 	      dirlen = strlen (users_dirname);
 	      temp = (char *)xmalloc (2 + dirlen + D_NAMLEN (entry));
 	      strcpy (temp, users_dirname);
+/* begin_clink_change
+ * Removed appending of a '/' to correctly support volume-relative paths.
+ */
+#if 0
 	      /* Make sure that temp has a trailing slash here. */
 	      if (users_dirname[dirlen - 1] != '/')
 		temp[dirlen++] = '/';
+#endif
+/* end_clink_change */
 	    }
 
 	  strcpy (temp + dirlen, convfn);
diff --git a/readline/readline/complete.c b/readline/readline/complete.c
index 0aec9c1..e5ce3e2 100644
--- a/readline/readline/complete.c
+++ b/readline/readline/complete.c
@@ -933,6 +933,14 @@ _rl_find_completion_word (fp, dp)
       /* FOUND_QUOTE is set so we know what kind of quotes we found. */
       for (scan = pass_next = 0; scan < end; scan = MB_NEXTCHAR (rl_line_buffer, scan, 1, MB_FIND_ANY))
 	{
+/* begin_clink_change
+ * The following assumes we want to use backslashes to escape the next
+ * character. This doesn't apply on Windows as a \ is the part separator. Removing
+ * this code stops strings like the following getting misunderstood by readline;
+ *
+ * c:\>foobar.bat "c:\Program Files\"
+ */
+#if 0
 	  if (pass_next)
 	    {
 	      pass_next = 0;
@@ -949,6 +957,8 @@ _rl_find_completion_word (fp, dp)
 	      found_quote |= RL_QF_BACKSLASH;
 	      continue;
 	    }
+#endif
+/* end_clink_change */
 
 	  if (quote_char != '\0')
 	    {
